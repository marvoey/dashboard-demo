schema {
  query: Query
}

directive @config(esType: String, index: Boolean, link: LinkConfig, preset: String, searchable: Boolean, source: String) on ENUM_VALUE | FIELD_DEFINITION

"""Repeat fragment fields as children selection by `depth`"""
directive @recursive(
  """Recursion level (default: `1`, max: `10`)"""
  depth: Int = 1
) on FIELD | INLINE_FRAGMENT

type AmazonHeroSection implements IData & _IComponent & _IContent & _IItem {
  BackgroundImage: ContentReference
  CardDescription(highlight: HighlightOptions): String
  CardImage: ContentReference
  CardLink: [Link]
  CardTitle(highlight: HighlightOptions): String
  Description(highlight: HighlightOptions): String
  Headline(highlight: HighlightOptions): String
  ScrollDownText: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type AmazonHeroSectionAutocomplete {
  BackgroundImage: ContentReferenceAutocomplete
  CardImage: ContentReferenceAutocomplete
  CardLink: LinkAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type AmazonHeroSectionFacet {
  BackgroundImage: ContentReferenceFacet
  CardDescription(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  CardImage: ContentReferenceFacet
  CardLink: LinkFacet
  CardTitle(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Description(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Headline(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input AmazonHeroSectionOrderByInput {
  BackgroundImage: ContentReferenceOrderByInput
  CardDescription: OrderBy
  CardImage: ContentReferenceOrderByInput
  CardLink: LinkOrderByInput
  CardTitle: OrderBy
  Description: OrderBy
  Headline: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type AmazonHeroSectionOutput {
  autocomplete: AmazonHeroSectionAutocomplete
  cursor: String
  facets: AmazonHeroSectionFacet
  item: AmazonHeroSection
  items: [AmazonHeroSection]
  total(all: Boolean): Int
}

input AmazonHeroSectionWhereInput {
  BackgroundImage: ContentReferenceWhereInput
  CardDescription: SearchableStringFilterInput
  CardImage: ContentReferenceWhereInput
  CardLink: LinkWhereInput
  CardTitle: SearchableStringFilterInput
  Description: SearchableStringFilterInput
  Headline: SearchableStringFilterInput
  _and: [AmazonHeroSectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [AmazonHeroSectionWhereInput]
  _or: [AmazonHeroSectionWhereInput]
}

type ArticleList implements IData & _IComponent & _IContent & _IItem {
  ArticleRoot: ContentReference
  IncludeAllSites: Boolean
  NumberOfArticles: Int
  Title(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ArticleListAutocomplete {
  ArticleRoot: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ArticleListFacet {
  ArticleRoot: ContentReferenceFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input ArticleListOrderByInput {
  ArticleRoot: ContentReferenceOrderByInput
  Title: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ArticleListOutput {
  autocomplete: ArticleListAutocomplete
  cursor: String
  facets: ArticleListFacet
  item: ArticleList
  items: [ArticleList]
  total(all: Boolean): Int
}

input ArticleListWhereInput {
  ArticleRoot: ContentReferenceWhereInput
  Title: SearchableStringFilterInput
  _and: [ArticleListWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ArticleListWhereInput]
  _or: [ArticleListWhereInput]
}

type ArticlePage implements IData & _IContent & _IItem & _IPage {
  Author(highlight: HighlightOptions): String
  AuthorEmail(highlight: HighlightOptions): String
  Body: SearchableRichText
  Heading(highlight: HighlightOptions): String
  PageAdminSettings: PageAdminSettingsProperty
  PromoImage: ContentReference
  SeoSettings: PageSeoSettingsProperty
  SubHeading(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ArticlePageAutocomplete {
  PromoImage: ContentReferenceAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ArticlePageFacet {
  Author(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  AuthorEmail(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Body: SearchableRichTextFacet
  Heading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  PageAdminSettings(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  PromoImage: ContentReferenceFacet
  SeoSettings: PageSeoSettingsPropertyFacet
  SubHeading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input ArticlePageOrderByInput {
  Author: OrderBy
  AuthorEmail: OrderBy
  Body: SearchableRichTextOrderByInput
  Heading: OrderBy
  PageAdminSettings: OrderBy
  PromoImage: ContentReferenceOrderByInput
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  SubHeading: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ArticlePageOutput {
  autocomplete: ArticlePageAutocomplete
  cursor: String
  facets: ArticlePageFacet
  item: ArticlePage
  items: [ArticlePage]
  total(all: Boolean): Int
}

input ArticlePageWhereInput {
  Author: SearchableStringFilterInput
  AuthorEmail: SearchableStringFilterInput
  Body: SearchableRichTextWhereInput
  Heading: SearchableStringFilterInput
  PageAdminSettings: StringFilterInput
  PromoImage: ContentReferenceWhereInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  SubHeading: SearchableStringFilterInput
  _and: [ArticlePageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ArticlePageWhereInput]
  _or: [ArticlePageWhereInput]
}

type AutoGeneratedSection implements IData & _IComponent & _IContent & _IItem & _ISection {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type AutoGeneratedSectionAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type AutoGeneratedSectionFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input AutoGeneratedSectionOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type AutoGeneratedSectionOutput {
  autocomplete: AutoGeneratedSectionAutocomplete
  cursor: String
  facets: AutoGeneratedSectionFacet
  item: AutoGeneratedSection
  items: [AutoGeneratedSection]
  total(all: Boolean): Int
}

input AutoGeneratedSectionWhereInput {
  _and: [AutoGeneratedSectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [AutoGeneratedSectionWhereInput]
  _or: [AutoGeneratedSectionWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type BlankExperience implements IData & _IContent & _IExperience & _IItem & _IPage {
  BlankExperienceSeoSettings: PageSeoSettingsProperty
  PageAdminSettings: PageAdminSettingsProperty
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type BlankExperienceAutocomplete {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type BlankExperienceFacet {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyFacet
  PageAdminSettings(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input BlankExperienceOrderByInput {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyOrderByInput
  PageAdminSettings: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type BlankExperienceOutput {
  autocomplete: BlankExperienceAutocomplete
  cursor: String
  facets: BlankExperienceFacet
  item: BlankExperience
  items: [BlankExperience]
  total(all: Boolean): Int
}

input BlankExperienceWhereInput {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyWhereInput
  PageAdminSettings: StringFilterInput
  _and: [BlankExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlankExperienceWhereInput]
  _or: [BlankExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type BlankSection implements IData & _IComponent & _IContent & _IItem & _ISection {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type BlankSectionAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type BlankSectionFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input BlankSectionOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type BlankSectionOutput {
  autocomplete: BlankSectionAutocomplete
  cursor: String
  facets: BlankSectionFacet
  item: BlankSection
  items: [BlankSection]
  total(all: Boolean): Int
}

input BlankSectionWhereInput {
  _and: [BlankSectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlankSectionWhereInput]
  _or: [BlankSectionWhereInput]
  composition: CompositionStructureNodeWhereInput
}

scalar Bool

input BoolFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int
  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: Boolean
  """`exist` matches results that have this field."""
  exist: Boolean
  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: Boolean
}

type Button implements IData & _IComponent & _IContent & _IItem {
  ButtonLabel(highlight: HighlightOptions): String
  ButtonLink: Link
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ButtonAutocomplete {
  ButtonLink: LinkAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ButtonFacet {
  ButtonLabel(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ButtonLink: LinkFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input ButtonOrderByInput {
  ButtonLabel: OrderBy
  ButtonLink: LinkOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ButtonOutput {
  autocomplete: ButtonAutocomplete
  cursor: String
  facets: ButtonFacet
  item: Button
  items: [Button]
  total(all: Boolean): Int
}

input ButtonWhereInput {
  ButtonLabel: SearchableStringFilterInput
  ButtonLink: LinkWhereInput
  _and: [ButtonWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ButtonWhereInput]
  _or: [ButtonWhereInput]
}

type CallToAction implements IData & _IComponent & _IContent & _IItem {
  Links: [Link]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type CallToActionAutocomplete {
  Links: LinkAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CallToActionFacet {
  Links: LinkFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input CallToActionOrderByInput {
  Links: LinkOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CallToActionOutput {
  autocomplete: CallToActionAutocomplete
  cursor: String
  facets: CallToActionFacet
  item: CallToAction
  items: [CallToAction]
  total(all: Boolean): Int
}

input CallToActionWhereInput {
  Links: LinkWhereInput
  _and: [CallToActionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CallToActionWhereInput]
  _or: [CallToActionWhereInput]
}

type Card implements IData & _IComponent & _IContent & _IItem {
  Asset: ContentReference
  Body: SearchableRichText
  DisplayAs: String
  Heading(highlight: HighlightOptions): String
  Links: [Link]
  SubHeading(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type CardAutocomplete {
  Asset: ContentReferenceAutocomplete
  Links: LinkAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CardFacet {
  Asset: ContentReferenceFacet
  Body: SearchableRichTextFacet
  Heading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Links: LinkFacet
  SubHeading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input CardOrderByInput {
  Asset: ContentReferenceOrderByInput
  Body: SearchableRichTextOrderByInput
  Heading: OrderBy
  Links: LinkOrderByInput
  SubHeading: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CardOutput {
  autocomplete: CardAutocomplete
  cursor: String
  facets: CardFacet
  item: Card
  items: [Card]
  total(all: Boolean): Int
}

input CardWhereInput {
  Asset: ContentReferenceWhereInput
  Body: SearchableRichTextWhereInput
  Heading: SearchableStringFilterInput
  Links: LinkWhereInput
  SubHeading: SearchableStringFilterInput
  _and: [CardWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CardWhereInput]
  _or: [CardWhereInput]
}

type Carousel implements IData & _IComponent & _IContent & _IItem {
  Assets: [Link]
  Heading(highlight: HighlightOptions): String
  Link: Link
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type CarouselAutocomplete {
  Assets: LinkAutocomplete
  Link: LinkAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CarouselFacet {
  Assets: LinkFacet
  Heading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Link: LinkFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input CarouselOrderByInput {
  Assets: LinkOrderByInput
  Heading: OrderBy
  Link: LinkOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CarouselOutput {
  autocomplete: CarouselAutocomplete
  cursor: String
  facets: CarouselFacet
  item: Carousel
  items: [Carousel]
  total(all: Boolean): Int
}

input CarouselWhereInput {
  Assets: LinkWhereInput
  Heading: SearchableStringFilterInput
  Link: LinkWhereInput
  _and: [CarouselWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CarouselWhereInput]
  _or: [CarouselWhereInput]
}

type Collapse implements IData & _IComponent & _IContent & _IItem {
  Body: SearchableRichText
  Heading(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type CollapseAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CollapseFacet {
  Body: SearchableRichTextFacet
  Heading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input CollapseOrderByInput {
  Body: SearchableRichTextOrderByInput
  Heading: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CollapseOutput {
  autocomplete: CollapseAutocomplete
  cursor: String
  facets: CollapseFacet
  item: Collapse
  items: [Collapse]
  total(all: Boolean): Int
}

input CollapseWhereInput {
  Body: SearchableRichTextWhereInput
  Heading: SearchableStringFilterInput
  _and: [CollapseWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CollapseWhereInput]
  _or: [CollapseWhereInput]
}

type CompositionComponentNode implements ICompositionComponentNode & ICompositionNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  type: String
}

type CompositionDisplaySetting {
  key: String
  value: String
}

type CompositionDisplaySettingAutocomplete {
  key(limit: Int! = 10, value: String!): [String]
  value(limit: Int! = 10, value: String!): [String]
}

type CompositionDisplaySettingFacet {
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  value(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input CompositionDisplaySettingOrderByInput {
  key: OrderBy
  value: OrderBy
}

input CompositionDisplaySettingWhereInput {
  key: StringFilterInput
  value: StringFilterInput
}

type CompositionNode implements ICompositionNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  type: String
}

type CompositionStructureNode implements ICompositionNode & ICompositionStructureNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  nodes: [ICompositionNode]
  type: String
}

type CompositionStructureNodeAutocomplete {
  displayName(limit: Int! = 10, value: String!): [String]
  displaySettings: CompositionDisplaySettingAutocomplete
  displayTemplateKey(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  layoutType(limit: Int! = 10, value: String!): [String]
  nodeType(limit: Int! = 10, value: String!): [String]
  nodes: ICompositionNodeAutocomplete
  type(limit: Int! = 10, value: String!): [String]
}

type CompositionStructureNodeFacet {
  component: _IComponentFacet
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  displaySettings: CompositionDisplaySettingFacet
  displayTemplateKey(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  layoutType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodes: ICompositionNodeFacet
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input CompositionStructureNodeOrderByInput {
  component: _IComponentOrderByInput
  displayName: OrderBy
  displaySettings: CompositionDisplaySettingOrderByInput
  displayTemplateKey: OrderBy
  key: OrderBy
  layoutType: OrderBy
  nodeType: OrderBy
  nodes: ICompositionNodeOrderByInput
  type: OrderBy
}

input CompositionStructureNodeWhereInput {
  component: _IComponentWhereInput
  displayName: StringFilterInput
  displaySettings: CompositionDisplaySettingWhereInput
  displayTemplateKey: StringFilterInput
  key: StringFilterInput
  layoutType: StringFilterInput
  nodeType: StringFilterInput
  nodes: ICompositionNodeWhereInput
  type: StringFilterInput
}

type ContentMetadata implements IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

type ContentReference {
  """
  `reference`
  |          |        |      |
  | -------: | ------ | :--- |
  | **type** | &nbsp; | `Data` |
  | **id**   | &nbsp; | `_id` |
  
  """
  item: IData
  key: String
  url: ContentUrl
}

type ContentReferenceAutocomplete {
  key(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
}

type ContentReferenceFacet {
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
}

input ContentReferenceOrderByInput {
  key: OrderBy
  url: ContentUrlOrderByInput
}

input ContentReferenceWhereInput {
  key: StringFilterInput
  url: ContentUrlWhereInput
}

type ContentUrl {
  base: String
  default: String
  graph: String
  hierarchical: String
  internal: String
  type: String
}

type ContentUrlAutocomplete {
  base(limit: Int! = 10, value: String!): [String]
  default(limit: Int! = 10, value: String!): [String]
  graph(limit: Int! = 10, value: String!): [String]
  hierarchical(limit: Int! = 10, value: String!): [String]
  internal(limit: Int! = 10, value: String!): [String]
  type(limit: Int! = 10, value: String!): [String]
}

type ContentUrlFacet {
  base(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  default(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  graph(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  hierarchical(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  internal(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input ContentUrlOrderByInput {
  base: OrderBy
  default: OrderBy
  graph: OrderBy
  hierarchical: OrderBy
  internal: OrderBy
  type: OrderBy
}

input ContentUrlWhereInput {
  base: StringFilterInput
  default: StringFilterInput
  graph: StringFilterInput
  hierarchical: StringFilterInput
  internal: StringFilterInput
  type: StringFilterInput
}

type CssMedia implements IData & _IAssetItem & _IContent & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type CssMediaAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CssMediaFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input CssMediaOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CssMediaOutput {
  autocomplete: CssMediaAutocomplete
  cursor: String
  facets: CssMediaFacet
  item: CssMedia
  items: [CssMedia]
  total(all: Boolean): Int
}

input CssMediaWhereInput {
  _and: [CssMediaWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CssMediaWhereInput]
  _or: [CssMediaWhereInput]
}

type Data implements IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

input DataOrderByInput {
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type DataOutput {
  cursor: String
  item: IData
  items: [IData]
  total(all: Boolean): Int
}

input DataWhereInput {
  _and: [DataWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [DataWhereInput]
  _or: [DataWhereInput]
}

scalar Date

type DateFacet {
  count: Int
  name: String
}

enum DateFacetUnit {
  """
  Defined as 24 hours (86,400,000 milliseconds). All days begin at the earliest possible time, which is usually 00:00:00 (midnight).
  """
  DAY
  """
  Defined as 60 minutes each (3,600,000 milliseconds). All hours begin at 00 minutes and 00 seconds.
  """
  HOUR
  """Defined as 1000 milliseconds each."""
  MINUTE
}

input DateFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int
  """
  `decay` influences the weight of the score with a decay function. For example, results that have a more recent datetime will be ranked higher. The `origin` will be `now()` in case not specified. The `scale` is by default 10. The `rate` must be in the range `[0..1]`.
  """
  decay: Decay
  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: Date
  """`exist` matches results that have this field."""
  exist: Boolean
  """
  `gt` retrieves results with matches that have a value which is `greater than` it.
  """
  gt: Date
  """
  `gte` retrieves results with matches that have a value which is `greater than or equal to` it.
  """
  gte: Date
  """
  `lt` retrieves results with matches that have a value which is `lower than` it.
  """
  lt: Date
  """
  `lte` retrieves results with matches that have a value which is `lower than or equal to` it.
  """
  lte: Date
  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: Date
}

scalar DateTime

"""
Decay influences the weight of the score based on field values with a decay function
"""
input Decay {
  origin: Date
  rate: Float
  scale: Int = 10
}

type Divider implements IData & _IComponent & _IContent & _IItem {
  DividerDirection: String
  DividerText: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type DividerAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type DividerFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input DividerOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type DividerOutput {
  autocomplete: DividerAutocomplete
  cursor: String
  facets: DividerFacet
  item: Divider
  items: [Divider]
  total(all: Boolean): Int
}

input DividerWhereInput {
  _and: [DividerWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [DividerWhereInput]
  _or: [DividerWhereInput]
}

type FacetedSearch implements IData & _IComponent & _IContent & _IItem {
  DefaultFiltersState: String
  DefaultSortOrder: String
  DefaultViewMode: String
  GridColumns: String
  IntroText: SearchableRichText
  ItemsPerPage: Int
  NoResultsMessage(highlight: HighlightOptions): String
  SearchPlaceholder(highlight: HighlightOptions): String
  SemanticWeight: String
  ShowAuthorFacet: Boolean
  ShowSearchInput: Boolean
  ShowTypeFacet: Boolean
  Title(highlight: HighlightOptions): String
  UseSemanticSearch: Boolean
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type FacetedSearchAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type FacetedSearchFacet {
  IntroText: SearchableRichTextFacet
  NoResultsMessage(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SearchPlaceholder(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input FacetedSearchOrderByInput {
  IntroText: SearchableRichTextOrderByInput
  NoResultsMessage: OrderBy
  SearchPlaceholder: OrderBy
  Title: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type FacetedSearchOutput {
  autocomplete: FacetedSearchAutocomplete
  cursor: String
  facets: FacetedSearchFacet
  item: FacetedSearch
  items: [FacetedSearch]
  total(all: Boolean): Int
}

input FacetedSearchWhereInput {
  IntroText: SearchableRichTextWhereInput
  NoResultsMessage: SearchableStringFilterInput
  SearchPlaceholder: SearchableStringFilterInput
  Title: SearchableStringFilterInput
  _and: [FacetedSearchWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [FacetedSearchWhereInput]
  _or: [FacetedSearchWhereInput]
}

enum FactorModifier {
  """Add 1 to the field value and take the natural logarithm"""
  LOG
  """Do not apply any multiplier to the field value"""
  NONE
  """Reciprocate the field value, same as 1/x where x is the field's value"""
  RECIPROCAL
  """Take the square root of the field value"""
  SQRT
  """Square the field value (multiply it by itself)"""
  SQUARE
}

type FolderPage implements IData & _IContent & _IItem & _IPage {
  FolderDescription: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type FolderPageAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type FolderPageFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input FolderPageOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type FolderPageOutput {
  autocomplete: FolderPageAutocomplete
  cursor: String
  facets: FolderPageFacet
  item: FolderPage
  items: [FolderPage]
  total(all: Boolean): Int
}

input FolderPageWhereInput {
  _and: [FolderPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [FolderPageWhereInput]
  _or: [FolderPageWhereInput]
}

type GenericMedia implements IData & _IAssetItem & _IContent & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type GenericMediaAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type GenericMediaFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input GenericMediaOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type GenericMediaOutput {
  autocomplete: GenericMediaAutocomplete
  cursor: String
  facets: GenericMediaFacet
  item: GenericMedia
  items: [GenericMedia]
  total(all: Boolean): Int
}

input GenericMediaWhereInput {
  _and: [GenericMediaWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [GenericMediaWhereInput]
  _or: [GenericMediaWhereInput]
}

type Grid implements IData & _IComponent & _IContent & _IItem {
  Items: [_IContent]
  RichText: SearchableRichText
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type GridAutocomplete {
  Items: _IContentAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type GridFacet {
  Items: _IContentFacet
  RichText: SearchableRichTextFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input GridOrderByInput {
  Items: _IContentOrderByInput
  RichText: SearchableRichTextOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type GridOutput {
  autocomplete: GridAutocomplete
  cursor: String
  facets: GridFacet
  item: Grid
  items: [Grid]
  total(all: Boolean): Int
}

input GridWhereInput {
  Items: _IContentWhereInput
  RichText: SearchableRichTextWhereInput
  _and: [GridWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [GridWhereInput]
  _or: [GridWhereInput]
}

type Hero implements IData & _IComponent & _IContent & _IItem {
  Body: SearchableRichText
  Heading(highlight: HighlightOptions): String
  Image: ContentReference
  Links: [Link]
  SubHeading(highlight: HighlightOptions): String
  Video: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type HeroAutocomplete {
  Image: ContentReferenceAutocomplete
  Links: LinkAutocomplete
  Video: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type HeroFacet {
  Body: SearchableRichTextFacet
  Heading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Image: ContentReferenceFacet
  Links: LinkFacet
  SubHeading(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Video: ContentReferenceFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input HeroOrderByInput {
  Body: SearchableRichTextOrderByInput
  Heading: OrderBy
  Image: ContentReferenceOrderByInput
  Links: LinkOrderByInput
  SubHeading: OrderBy
  Video: ContentReferenceOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type HeroOutput {
  autocomplete: HeroAutocomplete
  cursor: String
  facets: HeroFacet
  item: Hero
  items: [Hero]
  total(all: Boolean): Int
}

input HeroWhereInput {
  Body: SearchableRichTextWhereInput
  Heading: SearchableStringFilterInput
  Image: ContentReferenceWhereInput
  Links: LinkWhereInput
  SubHeading: SearchableStringFilterInput
  Video: ContentReferenceWhereInput
  _and: [HeroWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [HeroWhereInput]
  _or: [HeroWhereInput]
}

"""Options for highlighting"""
input HighlightOptions {
  enabled: Boolean
  endToken: String
  startToken: String
}

interface ICompositionComponentNode implements ICompositionNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  type: String
}

interface ICompositionNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  type: String
}

type ICompositionNodeAutocomplete {
  displayName(limit: Int! = 10, value: String!): [String]
  displaySettings: CompositionDisplaySettingAutocomplete
  displayTemplateKey(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  layoutType(limit: Int! = 10, value: String!): [String]
  nodeType(limit: Int! = 10, value: String!): [String]
  type(limit: Int! = 10, value: String!): [String]
}

type ICompositionNodeFacet {
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  displaySettings: CompositionDisplaySettingFacet
  displayTemplateKey(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  layoutType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input ICompositionNodeOrderByInput {
  displayName: OrderBy
  displaySettings: CompositionDisplaySettingOrderByInput
  displayTemplateKey: OrderBy
  key: OrderBy
  layoutType: OrderBy
  nodeType: OrderBy
  type: OrderBy
}

input ICompositionNodeWhereInput {
  displayName: StringFilterInput
  displaySettings: CompositionDisplaySettingWhereInput
  displayTemplateKey: StringFilterInput
  key: StringFilterInput
  layoutType: StringFilterInput
  nodeType: StringFilterInput
  type: StringFilterInput
}

interface ICompositionStructureNode implements ICompositionNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  layoutType: String
  nodeType: String
  nodes: [ICompositionNode]
  type: String
}

interface IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

type IContentMetadataAutocomplete {
  changeset(limit: Int! = 10, value: String!): [String]
  fallbackForLocale(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  locale(limit: Int! = 10, value: String!): [String]
  status(limit: Int! = 10, value: String!): [String]
  types(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
  variation(limit: Int! = 10, value: String!): [String]
  version(limit: Int! = 10, value: String!): [String]
}

type IContentMetadataFacet {
  changeset(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  created(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  fallbackForLocale(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  lastModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  locale(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  published(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  sortOrder(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  status(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  types(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
  variation(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  version(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input IContentMetadataOrderByInput {
  changeset: OrderBy
  created: OrderBy
  displayName: OrderBy
  fallbackForLocale: OrderBy
  key: OrderBy
  lastModified: OrderBy
  locale: OrderBy
  published: OrderBy
  sortOrder: OrderBy
  status: OrderBy
  types: OrderBy
  url: ContentUrlOrderByInput
  variation: OrderBy
  version: OrderBy
}

input IContentMetadataWhereInput {
  changeset: StringFilterInput
  created: DateFilterInput
  displayName: SearchableStringFilterInput
  fallbackForLocale: StringFilterInput
  key: StringFilterInput
  lastModified: DateFilterInput
  locale: StringFilterInput
  published: DateFilterInput
  sortOrder: IntFilterInput
  status: StringFilterInput
  types: StringFilterInput
  url: ContentUrlWhereInput
  variation: StringFilterInput
  version: StringFilterInput
}

interface IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

interface IInstanceMetadata implements IContentMetadata {
  changeset: String
  container: String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

interface IItemMetadata implements IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  displayOption: String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

interface IMediaMetadata implements IContentMetadata & IInstanceMetadata {
  changeset: String
  container: String
  content(highlight: HighlightOptions): String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  mimeType: String
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  sortOrder: Int
  status: String
  thumbnail: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

interface Icmp_Asset implements IData {
  DateCreated: Date
  DateModified: Date
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FolderGuids: [String]
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

interface Icmp_Field implements IData {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type Icmp_FieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type Icmp_FieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input Icmp_FieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

input Icmp_FieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [Icmp_FieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [Icmp_FieldWhereInput]
  _or: [Icmp_FieldWhereInput]
}

type Iframe implements IData & _IComponent & _IContent & _IItem {
  IframePageUrl: String
  ManualHeight: Int
  Title(highlight: HighlightOptions): String
  Width: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type IframeAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type IframeFacet {
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input IframeOrderByInput {
  Title: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type IframeOutput {
  autocomplete: IframeAutocomplete
  cursor: String
  facets: IframeFacet
  item: Iframe
  items: [Iframe]
  total(all: Boolean): Int
}

input IframeWhereInput {
  Title: SearchableStringFilterInput
  _and: [IframeWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [IframeWhereInput]
  _or: [IframeWhereInput]
}

type Image implements IData & _IComponent & _IContent & _IItem {
  AltText(highlight: HighlightOptions): String
  Image: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ImageAutocomplete {
  Image: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ImageFacet {
  AltText(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Image: ContentReferenceFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

type ImageMedia implements IData & _IAssetItem & _IContent & _IImage & _IImageItem & _IItem & _IMedia {
  AltText(highlight: HighlightOptions): String
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _imageMetadata: _ImageMetadata
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ImageMediaAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ImageMediaFacet {
  AltText(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _assetMetadata: _AssetMetadataFacet
  _imageMetadata: _ImageMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input ImageMediaOrderByInput {
  AltText: OrderBy
  _assetMetadata: _AssetMetadataOrderByInput
  _imageMetadata: _ImageMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ImageMediaOutput {
  autocomplete: ImageMediaAutocomplete
  cursor: String
  facets: ImageMediaFacet
  item: ImageMedia
  items: [ImageMedia]
  total(all: Boolean): Int
}

input ImageMediaWhereInput {
  AltText: SearchableStringFilterInput
  _and: [ImageMediaWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _imageMetadata: _ImageMetadataWhereInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ImageMediaWhereInput]
  _or: [ImageMediaWhereInput]
}

input ImageOrderByInput {
  AltText: OrderBy
  Image: ContentReferenceOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ImageOutput {
  autocomplete: ImageAutocomplete
  cursor: String
  facets: ImageFacet
  item: Image
  items: [Image]
  total(all: Boolean): Int
}

input ImageWhereInput {
  AltText: SearchableStringFilterInput
  Image: ContentReferenceWhereInput
  _and: [ImageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ImageWhereInput]
  _or: [ImageWhereInput]
}

type InstanceMetadata implements IContentMetadata & IInstanceMetadata {
  changeset: String
  container: String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

input IntFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int
  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: Int
  """`exist` matches results that have this field."""
  exist: Boolean
  """
  `Factor` allows you to use a number value in a field to influence the `_score` directly. If used on a multi-valued field, then only the lowest value of the field is used in calculations. Default for `value` is `1`. Default for `modifier` is `NONE`.
  """
  factor: NumberFactor
  """
  `gt` retrieves results with matches that have a value which is `greater than` it.
  """
  gt: Int
  """
  `gte` retrieves results with matches that have a value which is `greater than or equal to` it.
  """
  gte: Int
  """
  `in` matches with 1 or more exact values in a list. Example: `in: ["word1", "word2", "this is a phrase"]`
  """
  in: [Int]
  """
  `lt` retrieves results with matches that have a value which is `lower than` it.
  """
  lt: Int
  """
  `lte` retrieves results with matches that have a value which is `lower than or equal to` it.
  """
  lte: Int
  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: Int
  """
  `not_in` returns results that do not match with 1 or more exact values in a list. Example: `not_in: ["word1", "word2", "this is a phrase"]`
  """
  notIn: [Int]
}

type ItemMetadata implements IContentMetadata & IItemMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  displayOption: String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  sortOrder: Int
  status: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/publications-and-standards/standards/ecma-404/).
"""
scalar JSON

type LandingPage implements IData & _IContent & _IItem & _IPage {
  MainContentArea: [_IContent]
  PageAdminSettings: PageAdminSettingsProperty
  SeoSettings: PageSeoSettingsProperty
  TopContentArea: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type LandingPageAutocomplete {
  MainContentArea: _IContentAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  TopContentArea: _IContentAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type LandingPageFacet {
  MainContentArea: _IContentFacet
  PageAdminSettings(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SeoSettings: PageSeoSettingsPropertyFacet
  TopContentArea: _IContentFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input LandingPageOrderByInput {
  MainContentArea: _IContentOrderByInput
  PageAdminSettings: OrderBy
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  TopContentArea: _IContentOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type LandingPageOutput {
  autocomplete: LandingPageAutocomplete
  cursor: String
  facets: LandingPageFacet
  item: LandingPage
  items: [LandingPage]
  total(all: Boolean): Int
}

input LandingPageWhereInput {
  MainContentArea: _IContentWhereInput
  PageAdminSettings: StringFilterInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  TopContentArea: _IContentWhereInput
  _and: [LandingPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [LandingPageWhereInput]
  _or: [LandingPageWhereInput]
}

type Link {
  target: String
  text(highlight: HighlightOptions): String
  title: String
  url: ContentUrl
}

type LinkAutocomplete {
  target(limit: Int! = 10, value: String!): [String]
  title(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
}

input LinkConfig {
  from: String
  to: String
}

type LinkFacet {
  target(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  text(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
}

input LinkOrderByInput {
  target: OrderBy
  text: OrderBy
  title: OrderBy
  url: ContentUrlOrderByInput
}

enum LinkTypes {
  """
  
  | *Direction* | &nbsp; | *Field*     |
  | ----------: | ------ | :---------- |
  | *from*      |        | `_metadata.key` |
  | *to*        |        | `_metadata.owner`   |
  """
  ASSETS
  """
  
  | *Direction* | &nbsp; | *Field*     |
  | ----------: | ------ | :---------- |
  | *from*      |        | `ContentLink.GuidValue` |
  | *to*        |        | `ParentLink.GuidValue`   |
  """
  DEFAULT
  """
  
  | *Direction* | &nbsp; | *Field*     |
  | ----------: | ------ | :---------- |
  | *from*      |        | `_metadata.key` |
  | *to*        |        | `_metadata.container`   |
  """
  ITEMS
  """
  
  | *Direction* | &nbsp; | *Field*     |
  | ----------: | ------ | :---------- |
  | *from*      |        | `_metadata.path` |
  | *to*        |        | `_metadata.key`   |
  """
  PATH
}

input LinkWhereInput {
  target: StringFilterInput
  text: SearchableStringFilterInput
  title: StringFilterInput
  url: ContentUrlWhereInput
}

enum Locales {
  ALL
  NEUTRAL
  de
  en
  en_GB
  en_NZ
  nl_BE
  sv
}

type Marvin5Experience implements IData & _IContent & _IExperience & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
  field1(highlight: HighlightOptions): String
  field2(highlight: HighlightOptions): String
}

type Marvin5ExperienceAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type Marvin5ExperienceFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
  field1(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  field2(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input Marvin5ExperienceOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
  field1: OrderBy
  field2: OrderBy
}

type Marvin5ExperienceOutput {
  autocomplete: Marvin5ExperienceAutocomplete
  cursor: String
  facets: Marvin5ExperienceFacet
  item: Marvin5Experience
  items: [Marvin5Experience]
  total(all: Boolean): Int
}

input Marvin5ExperienceWhereInput {
  _and: [Marvin5ExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [Marvin5ExperienceWhereInput]
  _or: [Marvin5ExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
  field1: SearchableStringFilterInput
  field2: SearchableStringFilterInput
}

type MarvinExperience implements IData & _IContent & _IExperience & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type MarvinExperienceAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type MarvinExperienceFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input MarvinExperienceOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type MarvinExperienceOutput {
  autocomplete: MarvinExperienceAutocomplete
  cursor: String
  facets: MarvinExperienceFacet
  item: MarvinExperience
  items: [MarvinExperience]
  total(all: Boolean): Int
}

input MarvinExperienceWhereInput {
  _and: [MarvinExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [MarvinExperienceWhereInput]
  _or: [MarvinExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type MediaMetadata implements IContentMetadata & IInstanceMetadata & IMediaMetadata {
  changeset: String
  container: String
  content(highlight: HighlightOptions): String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  mimeType: String
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  sortOrder: Int
  status: String
  thumbnail: String
  types: [String]
  url: ContentUrl
  variation: String
  version: String
}

type MenuItem implements IData & _IComponent & _IContent & _IItem {
  Link: Link
  LinkText: String
  SubMenuItems: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type MenuItemAutocomplete {
  Link: LinkAutocomplete
  SubMenuItems: _IContentAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type MenuItemFacet {
  Link: LinkFacet
  SubMenuItems: _IContentFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input MenuItemOrderByInput {
  Link: LinkOrderByInput
  SubMenuItems: _IContentOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type MenuItemOutput {
  autocomplete: MenuItemAutocomplete
  cursor: String
  facets: MenuItemFacet
  item: MenuItem
  items: [MenuItem]
  total(all: Boolean): Int
}

input MenuItemWhereInput {
  Link: LinkWhereInput
  SubMenuItems: _IContentWhereInput
  _and: [MenuItemWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [MenuItemWhereInput]
  _or: [MenuItemWhereInput]
}

type MockupPage implements IData & _IContent & _IItem & _IPage {
  HtmlMockup: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type MockupPageAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type MockupPageFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input MockupPageOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type MockupPageOutput {
  autocomplete: MockupPageAutocomplete
  cursor: String
  facets: MockupPageFacet
  item: MockupPage
  items: [MockupPage]
  total(all: Boolean): Int
}

input MockupPageWhereInput {
  _and: [MockupPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [MockupPageWhereInput]
  _or: [MockupPageWhereInput]
}

type NumberFacet {
  count: Int
  name: String
}

"""
Factor influences the score based of number values with a factor function
"""
input NumberFactor {
  modifier: FactorModifier
  value: Float
}

type OdpForm implements IData & _IComponent & _IContent & _IItem {
  SelectorName: String
  SelectorType: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OdpFormAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OdpFormFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OdpFormOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OdpFormOutput {
  autocomplete: OdpFormAutocomplete
  cursor: String
  facets: OdpFormFacet
  item: OdpForm
  items: [OdpForm]
  total(all: Boolean): Int
}

input OdpFormWhereInput {
  _and: [OdpFormWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OdpFormWhereInput]
  _or: [OdpFormWhereInput]
}

type OptiFormsChoiceElement implements IData & _IComponent & _IContent & _IItem {
  AllowMultiSelect: Boolean
  Label: String
  Options: JSON
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsChoiceElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsChoiceElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsChoiceElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsChoiceElementOutput {
  autocomplete: OptiFormsChoiceElementAutocomplete
  cursor: String
  facets: OptiFormsChoiceElementFacet
  item: OptiFormsChoiceElement
  items: [OptiFormsChoiceElement]
  total(all: Boolean): Int
}

input OptiFormsChoiceElementWhereInput {
  _and: [OptiFormsChoiceElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsChoiceElementWhereInput]
  _or: [OptiFormsChoiceElementWhereInput]
}

type OptiFormsCondition implements IData & _IComponent & _IContent & _IItem {
  ComparisonOperator: String
  ComparisonValue: String
  DependsOnField: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsConditionAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsConditionFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsConditionOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsConditionOutput {
  autocomplete: OptiFormsConditionAutocomplete
  cursor: String
  facets: OptiFormsConditionFacet
  item: OptiFormsCondition
  items: [OptiFormsCondition]
  total(all: Boolean): Int
}

type OptiFormsConditionProperty {
  ComparisonOperator: String
  ComparisonValue: String
  DependsOnField: String
}

input OptiFormsConditionWhereInput {
  _and: [OptiFormsConditionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsConditionWhereInput]
  _or: [OptiFormsConditionWhereInput]
}

type OptiFormsContainerData implements IData & _IComponent & _IContent & _IItem & _ISection {
  DependencyRules: [OptiFormsDependencyRuleProperty]
  Description: String
  ResetConfirmationMessage: String
  ShowSummaryMessageAfterSubmission: Boolean
  SubmitConfirmationMessage: String
  SubmitUrl: ContentUrl
  Title: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type OptiFormsContainerDataAutocomplete {
  SubmitUrl: ContentUrlAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type OptiFormsContainerDataFacet {
  DependencyRules: OptiFormsDependencyRulePropertyFacet
  SubmitUrl: ContentUrlFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input OptiFormsContainerDataOrderByInput {
  DependencyRules: OptiFormsDependencyRulePropertyOrderByInput
  SubmitUrl: ContentUrlOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type OptiFormsContainerDataOutput {
  autocomplete: OptiFormsContainerDataAutocomplete
  cursor: String
  facets: OptiFormsContainerDataFacet
  item: OptiFormsContainerData
  items: [OptiFormsContainerData]
  total(all: Boolean): Int
}

input OptiFormsContainerDataWhereInput {
  DependencyRules: OptiFormsDependencyRulePropertyWhereInput
  SubmitUrl: ContentUrlWhereInput
  _and: [OptiFormsContainerDataWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsContainerDataWhereInput]
  _or: [OptiFormsContainerDataWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type OptiFormsDependencyRule implements IData & _IComponent & _IContent & _IItem {
  ConditionCombination: String
  Conditions: [OptiFormsConditionProperty]
  SatisfiedAction: String
  TargetElement: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsDependencyRuleAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsDependencyRuleFacet {
  Conditions(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsDependencyRuleOrderByInput {
  Conditions: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsDependencyRuleOutput {
  autocomplete: OptiFormsDependencyRuleAutocomplete
  cursor: String
  facets: OptiFormsDependencyRuleFacet
  item: OptiFormsDependencyRule
  items: [OptiFormsDependencyRule]
  total(all: Boolean): Int
}

type OptiFormsDependencyRuleProperty {
  ConditionCombination: String
  Conditions: [OptiFormsConditionProperty]
  SatisfiedAction: String
  TargetElement: String
}

type OptiFormsDependencyRulePropertyFacet {
  Conditions(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input OptiFormsDependencyRulePropertyOrderByInput {
  Conditions: OrderBy
}

input OptiFormsDependencyRulePropertyWhereInput {
  Conditions: StringFilterInput
}

input OptiFormsDependencyRuleWhereInput {
  Conditions: StringFilterInput
  _and: [OptiFormsDependencyRuleWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsDependencyRuleWhereInput]
  _or: [OptiFormsDependencyRuleWhereInput]
}

type OptiFormsNumberElement implements IData & _IComponent & _IContent & _IItem {
  AutoComplete: String
  Label: String
  Placeholder: String
  PredefinedValue: String
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsNumberElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsNumberElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsNumberElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsNumberElementOutput {
  autocomplete: OptiFormsNumberElementAutocomplete
  cursor: String
  facets: OptiFormsNumberElementFacet
  item: OptiFormsNumberElement
  items: [OptiFormsNumberElement]
  total(all: Boolean): Int
}

input OptiFormsNumberElementWhereInput {
  _and: [OptiFormsNumberElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsNumberElementWhereInput]
  _or: [OptiFormsNumberElementWhereInput]
}

type OptiFormsRangeElement implements IData & _IComponent & _IContent & _IItem {
  Increment: Int
  Label: String
  Max: Int
  Min: Int
  PredefinedValue: String
  Tooltip: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsRangeElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsRangeElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsRangeElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsRangeElementOutput {
  autocomplete: OptiFormsRangeElementAutocomplete
  cursor: String
  facets: OptiFormsRangeElementFacet
  item: OptiFormsRangeElement
  items: [OptiFormsRangeElement]
  total(all: Boolean): Int
}

input OptiFormsRangeElementWhereInput {
  _and: [OptiFormsRangeElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsRangeElementWhereInput]
  _or: [OptiFormsRangeElementWhereInput]
}

type OptiFormsResetElement implements IData & _IComponent & _IContent & _IItem {
  Label: String
  Tooltip: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsResetElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsResetElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsResetElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsResetElementOutput {
  autocomplete: OptiFormsResetElementAutocomplete
  cursor: String
  facets: OptiFormsResetElementFacet
  item: OptiFormsResetElement
  items: [OptiFormsResetElement]
  total(all: Boolean): Int
}

input OptiFormsResetElementWhereInput {
  _and: [OptiFormsResetElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsResetElementWhereInput]
  _or: [OptiFormsResetElementWhereInput]
}

type OptiFormsSelectionElement implements IData & _IComponent & _IContent & _IItem {
  AllowMultiSelect: Boolean
  AutoComplete: String
  Label: String
  Options: JSON
  Placeholder: String
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsSelectionElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsSelectionElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsSelectionElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsSelectionElementOutput {
  autocomplete: OptiFormsSelectionElementAutocomplete
  cursor: String
  facets: OptiFormsSelectionElementFacet
  item: OptiFormsSelectionElement
  items: [OptiFormsSelectionElement]
  total(all: Boolean): Int
}

input OptiFormsSelectionElementWhereInput {
  _and: [OptiFormsSelectionElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsSelectionElementWhereInput]
  _or: [OptiFormsSelectionElementWhereInput]
}

type OptiFormsSubmitElement implements IData & _IComponent & _IContent & _IItem {
  Label: String
  Tooltip: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsSubmitElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsSubmitElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsSubmitElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsSubmitElementOutput {
  autocomplete: OptiFormsSubmitElementAutocomplete
  cursor: String
  facets: OptiFormsSubmitElementFacet
  item: OptiFormsSubmitElement
  items: [OptiFormsSubmitElement]
  total(all: Boolean): Int
}

input OptiFormsSubmitElementWhereInput {
  _and: [OptiFormsSubmitElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsSubmitElementWhereInput]
  _or: [OptiFormsSubmitElementWhereInput]
}

type OptiFormsTextareaElement implements IData & _IComponent & _IContent & _IItem {
  AutoComplete: String
  Label: String
  Placeholder: String
  PredefinedValue: String
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsTextareaElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsTextareaElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsTextareaElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsTextareaElementOutput {
  autocomplete: OptiFormsTextareaElementAutocomplete
  cursor: String
  facets: OptiFormsTextareaElementFacet
  item: OptiFormsTextareaElement
  items: [OptiFormsTextareaElement]
  total(all: Boolean): Int
}

input OptiFormsTextareaElementWhereInput {
  _and: [OptiFormsTextareaElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsTextareaElementWhereInput]
  _or: [OptiFormsTextareaElementWhereInput]
}

type OptiFormsTextboxElement implements IData & _IComponent & _IContent & _IItem {
  AutoComplete: String
  Label: String
  Placeholder: String
  PredefinedValue: String
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsTextboxElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsTextboxElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsTextboxElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsTextboxElementOutput {
  autocomplete: OptiFormsTextboxElementAutocomplete
  cursor: String
  facets: OptiFormsTextboxElementFacet
  item: OptiFormsTextboxElement
  items: [OptiFormsTextboxElement]
  total(all: Boolean): Int
}

input OptiFormsTextboxElementWhereInput {
  _and: [OptiFormsTextboxElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsTextboxElementWhereInput]
  _or: [OptiFormsTextboxElementWhereInput]
}

type OptiFormsUrlElement implements IData & _IComponent & _IContent & _IItem {
  Label: String
  Placeholder: String
  PredefinedValue: String
  Tooltip: String
  Validators: JSON
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type OptiFormsUrlElementAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type OptiFormsUrlElementFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input OptiFormsUrlElementOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type OptiFormsUrlElementOutput {
  autocomplete: OptiFormsUrlElementAutocomplete
  cursor: String
  facets: OptiFormsUrlElementFacet
  item: OptiFormsUrlElement
  items: [OptiFormsUrlElement]
  total(all: Boolean): Int
}

input OptiFormsUrlElementWhereInput {
  _and: [OptiFormsUrlElementWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [OptiFormsUrlElementWhereInput]
  _or: [OptiFormsUrlElementWhereInput]
}

enum OrderBy {
  ASC
  DESC
}

enum OrderByFacetType {
  COUNT
  VALUE
}

type PageAdminSettings implements IData & _IComponent & _IContent & _IItem {
  EnableExternalPreview: Boolean
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type PageAdminSettingsAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PageAdminSettingsFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input PageAdminSettingsOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PageAdminSettingsOutput {
  autocomplete: PageAdminSettingsAutocomplete
  cursor: String
  facets: PageAdminSettingsFacet
  item: PageAdminSettings
  items: [PageAdminSettings]
  total(all: Boolean): Int
}

type PageAdminSettingsProperty {
  EnableExternalPreview: Boolean
}

input PageAdminSettingsWhereInput {
  _and: [PageAdminSettingsWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PageAdminSettingsWhereInput]
  _or: [PageAdminSettingsWhereInput]
}

type PageSeoSettings implements IData & _IComponent & _IContent & _IItem {
  DisplayInMenu: Boolean
  GraphType: String
  Indexing: Boolean
  MetaDescription(highlight: HighlightOptions): String
  MetaTitle(highlight: HighlightOptions): String
  SharingImage: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type PageSeoSettingsAutocomplete {
  SharingImage: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PageSeoSettingsFacet {
  MetaDescription(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MetaTitle(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SharingImage: ContentReferenceFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input PageSeoSettingsOrderByInput {
  MetaDescription: OrderBy
  MetaTitle: OrderBy
  SharingImage: ContentReferenceOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PageSeoSettingsOutput {
  autocomplete: PageSeoSettingsAutocomplete
  cursor: String
  facets: PageSeoSettingsFacet
  item: PageSeoSettings
  items: [PageSeoSettings]
  total(all: Boolean): Int
}

type PageSeoSettingsProperty {
  DisplayInMenu: Boolean
  GraphType: String
  Indexing: Boolean
  MetaDescription(highlight: HighlightOptions): String
  MetaTitle(highlight: HighlightOptions): String
  SharingImage: ContentReference
}

type PageSeoSettingsPropertyAutocomplete {
  SharingImage: ContentReferenceAutocomplete
}

type PageSeoSettingsPropertyFacet {
  MetaDescription(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MetaTitle(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SharingImage: ContentReferenceFacet
}

input PageSeoSettingsPropertyOrderByInput {
  MetaDescription: OrderBy
  MetaTitle: OrderBy
  SharingImage: ContentReferenceOrderByInput
}

input PageSeoSettingsPropertyWhereInput {
  MetaDescription: SearchableStringFilterInput
  MetaTitle: SearchableStringFilterInput
  SharingImage: ContentReferenceWhereInput
}

input PageSeoSettingsWhereInput {
  MetaDescription: SearchableStringFilterInput
  MetaTitle: SearchableStringFilterInput
  SharingImage: ContentReferenceWhereInput
  _and: [PageSeoSettingsWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PageSeoSettingsWhereInput]
  _or: [PageSeoSettingsWhereInput]
}

type Paragraph implements IData & _IComponent & _IContent & _IItem {
  Text: SearchableRichText
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type ParagraphAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ParagraphFacet {
  Text: SearchableRichTextFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input ParagraphOrderByInput {
  Text: SearchableRichTextOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ParagraphOutput {
  autocomplete: ParagraphAutocomplete
  cursor: String
  facets: ParagraphFacet
  item: Paragraph
  items: [Paragraph]
  total(all: Boolean): Int
}

input ParagraphWhereInput {
  Text: SearchableRichTextWhereInput
  _and: [ParagraphWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ParagraphWhereInput]
  _or: [ParagraphWhereInput]
}

input PinnedInput {
  """Pinned collection keys"""
  collections: [String]
  phrase: String
}

type PlaceholderItem implements IData & _IComponent & _IContent & _IItem {
  Key: String
  Value: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type PlaceholderItemAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PlaceholderItemFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input PlaceholderItemOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PlaceholderItemOutput {
  autocomplete: PlaceholderItemAutocomplete
  cursor: String
  facets: PlaceholderItemFacet
  item: PlaceholderItem
  items: [PlaceholderItem]
  total(all: Boolean): Int
}

input PlaceholderItemWhereInput {
  _and: [PlaceholderItemWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PlaceholderItemWhereInput]
  _or: [PlaceholderItemWhereInput]
}

type PlaceholdersConfiguration implements IData & _IComponent & _IContent & _IItem {
  Domain: String
  Placeholders: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type PlaceholdersConfigurationAutocomplete {
  Domain(limit: Int! = 10, value: String!): [String]
  Placeholders: _IContentAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PlaceholdersConfigurationFacet {
  Domain(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Placeholders: _IContentFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input PlaceholdersConfigurationOrderByInput {
  Domain: OrderBy
  Placeholders: _IContentOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PlaceholdersConfigurationOutput {
  autocomplete: PlaceholdersConfigurationAutocomplete
  cursor: String
  facets: PlaceholdersConfigurationFacet
  item: PlaceholdersConfiguration
  items: [PlaceholdersConfiguration]
  total(all: Boolean): Int
}

input PlaceholdersConfigurationWhereInput {
  Domain: StringFilterInput
  Placeholders: _IContentWhereInput
  _and: [PlaceholdersConfigurationWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PlaceholdersConfigurationWhereInput]
  _or: [PlaceholdersConfigurationWhereInput]
}

type PressRelease implements IData & _IContent & _IItem & _IPage {
  Author(highlight: HighlightOptions): String
  BodyContent: SearchableRichText
  Summary(highlight: HighlightOptions): String
  Title(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type PressReleaseAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PressReleaseFacet {
  Author(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  BodyContent: SearchableRichTextFacet
  Summary(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input PressReleaseOrderByInput {
  Author: OrderBy
  BodyContent: SearchableRichTextOrderByInput
  Summary: OrderBy
  Title: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PressReleaseOutput {
  autocomplete: PressReleaseAutocomplete
  cursor: String
  facets: PressReleaseFacet
  item: PressRelease
  items: [PressRelease]
  total(all: Boolean): Int
}

input PressReleaseWhereInput {
  Author: SearchableStringFilterInput
  BodyContent: SearchableRichTextWhereInput
  Summary: SearchableStringFilterInput
  Title: SearchableStringFilterInput
  _and: [PressReleaseWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PressReleaseWhereInput]
  _or: [PressReleaseWhereInput]
}

type Query {
  AmazonHeroSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: AmazonHeroSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: AmazonHeroSectionWhereInput): AmazonHeroSectionOutput
  ArticleList(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticleListOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ArticleListWhereInput): ArticleListOutput
  ArticlePage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticlePageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ArticlePageWhereInput): ArticlePageOutput
  AutoGeneratedSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: AutoGeneratedSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: AutoGeneratedSectionWhereInput): AutoGeneratedSectionOutput
  BlankExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: BlankExperienceWhereInput): BlankExperienceOutput
  BlankSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: BlankSectionWhereInput): BlankSectionOutput
  Button(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ButtonOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ButtonWhereInput): ButtonOutput
  CallToAction(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CallToActionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CallToActionWhereInput): CallToActionOutput
  Card(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CardOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CardWhereInput): CardOutput
  Carousel(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CarouselOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CarouselWhereInput): CarouselOutput
  Collapse(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CollapseOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CollapseWhereInput): CollapseOutput
  CssMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CssMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CssMediaWhereInput): CssMediaOutput
  Data(cursor: String, ids: [String], limit: Int! = 20, locale: [system_Locales], orderBy: DataOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: DataWhereInput): DataOutput
  Divider(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: DividerOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: DividerWhereInput): DividerOutput
  FacetedSearch(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: FacetedSearchOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: FacetedSearchWhereInput): FacetedSearchOutput
  FolderPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: FolderPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: FolderPageWhereInput): FolderPageOutput
  GenericMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GenericMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: GenericMediaWhereInput): GenericMediaOutput
  Grid(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GridOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: GridWhereInput): GridOutput
  Hero(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeroOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: HeroWhereInput): HeroOutput
  Iframe(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: IframeOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: IframeWhereInput): IframeOutput
  Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ImageWhereInput): ImageOutput
  ImageMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ImageMediaWhereInput): ImageMediaOutput
  LandingPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LandingPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: LandingPageWhereInput): LandingPageOutput
  Marvin5Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: Marvin5ExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: Marvin5ExperienceWhereInput): Marvin5ExperienceOutput
  MarvinExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MarvinExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MarvinExperienceWhereInput): MarvinExperienceOutput
  MenuItem(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MenuItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MenuItemWhereInput): MenuItemOutput
  MockupPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MockupPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MockupPageWhereInput): MockupPageOutput
  OdpForm(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OdpFormOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OdpFormWhereInput): OdpFormOutput
  OptiFormsChoiceElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsChoiceElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsChoiceElementWhereInput): OptiFormsChoiceElementOutput
  OptiFormsCondition(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsConditionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsConditionWhereInput): OptiFormsConditionOutput
  OptiFormsContainerData(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsContainerDataOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsContainerDataWhereInput): OptiFormsContainerDataOutput
  OptiFormsDependencyRule(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsDependencyRuleOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsDependencyRuleWhereInput): OptiFormsDependencyRuleOutput
  OptiFormsNumberElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsNumberElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsNumberElementWhereInput): OptiFormsNumberElementOutput
  OptiFormsRangeElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsRangeElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsRangeElementWhereInput): OptiFormsRangeElementOutput
  OptiFormsResetElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsResetElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsResetElementWhereInput): OptiFormsResetElementOutput
  OptiFormsSelectionElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsSelectionElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsSelectionElementWhereInput): OptiFormsSelectionElementOutput
  OptiFormsSubmitElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsSubmitElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsSubmitElementWhereInput): OptiFormsSubmitElementOutput
  OptiFormsTextareaElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsTextareaElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsTextareaElementWhereInput): OptiFormsTextareaElementOutput
  OptiFormsTextboxElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsTextboxElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsTextboxElementWhereInput): OptiFormsTextboxElementOutput
  OptiFormsUrlElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsUrlElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsUrlElementWhereInput): OptiFormsUrlElementOutput
  PageAdminSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageAdminSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PageAdminSettingsWhereInput): PageAdminSettingsOutput
  PageSeoSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageSeoSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PageSeoSettingsWhereInput): PageSeoSettingsOutput
  Paragraph(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ParagraphOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ParagraphWhereInput): ParagraphOutput
  PlaceholderItem(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PlaceholderItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PlaceholderItemWhereInput): PlaceholderItemOutput
  PlaceholdersConfiguration(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PlaceholdersConfigurationOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PlaceholdersConfigurationWhereInput): PlaceholdersConfigurationOutput
  PressRelease(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PressReleaseOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PressReleaseWhereInput): PressReleaseOutput
  SiteSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SiteSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SiteSettingsWhereInput): SiteSettingsOutput
  SiteStyles(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SiteStylesOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SiteStylesWhereInput): SiteStylesOutput
  SysContentFolder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SysContentFolderOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SysContentFolderWhereInput): SysContentFolderOutput
  TestimonialCard(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TestimonialCardOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TestimonialCardWhereInput): TestimonialCardOutput
  TestimonialCardComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TestimonialCardComponentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TestimonialCardComponentWhereInput): TestimonialCardComponentOutput
  Text(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TextOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TextWhereInput): TextOutput
  Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoWhereInput): VideoOutput
  VideoExternal(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoExternalOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoExternalWhereInput): VideoExternalOutput
  VideoMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoMediaWhereInput): VideoMediaOutput
  _AssetItem(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _AssetItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _AssetItemWhereInput): _AssetItemOutput
  _Component(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ComponentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ComponentWhereInput): _ComponentOutput
  _Content(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ContentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ContentWhereInput): _ContentOutput
  _Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ExperienceWhereInput): _ExperienceOutput
  _Folder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _FolderOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _FolderWhereInput): _FolderOutput
  _Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ImageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ImageWhereInput): _ImageOutput
  _ImageItem(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _ImageItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ImageItemWhereInput): _ImageItemOutput
  _Item(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _ItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ItemWhereInput): _ItemOutput
  _Media(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _MediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _MediaWhereInput): _MediaOutput
  _Page(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _PageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _PageWhereInput): _PageOutput
  _Section(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _SectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _SectionWhereInput): _SectionOutput
  _Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _VideoOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _VideoWhereInput): _VideoOutput
  amazon_exchange_experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: amazon_exchange_experienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: amazon_exchange_experienceWhereInput): amazon_exchange_experienceOutput
  cmp_Asset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_AssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_AssetWhereInput): cmp_AssetOutput
  cmp_CheckboxField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_CheckboxFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_CheckboxFieldWhereInput): cmp_CheckboxFieldOutput
  cmp_CurrencyField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_CurrencyFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_CurrencyFieldWhereInput): cmp_CurrencyFieldOutput
  cmp_DateField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_DateFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_DateFieldWhereInput): cmp_DateFieldOutput
  cmp_DropdownField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_DropdownFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_DropdownFieldWhereInput): cmp_DropdownFieldOutput
  cmp_Field(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_FieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_FieldWhereInput): cmp_FieldOutput
  cmp_ImageField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_ImageFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_ImageFieldWhereInput): cmp_ImageFieldOutput
  cmp_LabelField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_LabelFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_LabelFieldWhereInput): cmp_LabelFieldOutput
  cmp_NumberField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_NumberFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_NumberFieldWhereInput): cmp_NumberFieldOutput
  cmp_PercentField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PercentFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PercentFieldWhereInput): cmp_PercentFieldOutput
  cmp_PublicImageAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicImageAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicImageAssetWhereInput): cmp_PublicImageAssetOutput
  cmp_PublicRawFileAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicRawFileAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicRawFileAssetWhereInput): cmp_PublicRawFileAssetOutput
  cmp_PublicVideoAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicVideoAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicVideoAssetWhereInput): cmp_PublicVideoAssetOutput
  cmp_RadioField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_RadioFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_RadioFieldWhereInput): cmp_RadioFieldOutput
  cmp_RichTextField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_RichTextFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_RichTextFieldWhereInput): cmp_RichTextFieldOutput
  cmp_StructuredContentAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_StructuredContentAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_StructuredContentAssetWhereInput): cmp_StructuredContentAssetOutput
  cmp_TextAreaField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_TextAreaFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_TextAreaFieldWhereInput): cmp_TextAreaFieldOutput
  cmp_TextField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_TextFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_TextFieldWhereInput): cmp_TextFieldOutput
  cmp_VideoField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_VideoFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_VideoFieldWhereInput): cmp_VideoFieldOutput
  marvinBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: marvinBlockOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: marvinBlockWhereInput): marvinBlockOutput
  test(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: testOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: testWhereInput): testOutput
}

type QueryRef {
  AmazonHeroSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: AmazonHeroSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: AmazonHeroSectionWhereInput): AmazonHeroSectionOutput
  ArticleList(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticleListOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ArticleListWhereInput): ArticleListOutput
  ArticlePage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticlePageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ArticlePageWhereInput): ArticlePageOutput
  AutoGeneratedSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: AutoGeneratedSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: AutoGeneratedSectionWhereInput): AutoGeneratedSectionOutput
  BlankExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: BlankExperienceWhereInput): BlankExperienceOutput
  BlankSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankSectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: BlankSectionWhereInput): BlankSectionOutput
  Button(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ButtonOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ButtonWhereInput): ButtonOutput
  CallToAction(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CallToActionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CallToActionWhereInput): CallToActionOutput
  Card(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CardOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CardWhereInput): CardOutput
  Carousel(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CarouselOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CarouselWhereInput): CarouselOutput
  Collapse(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CollapseOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CollapseWhereInput): CollapseOutput
  CssMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CssMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: CssMediaWhereInput): CssMediaOutput
  Data(cursor: String, ids: [String], limit: Int! = 20, locale: [system_Locales], orderBy: DataOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: DataWhereInput): DataOutput
  Divider(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: DividerOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: DividerWhereInput): DividerOutput
  FacetedSearch(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: FacetedSearchOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: FacetedSearchWhereInput): FacetedSearchOutput
  FolderPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: FolderPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: FolderPageWhereInput): FolderPageOutput
  GenericMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GenericMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: GenericMediaWhereInput): GenericMediaOutput
  Grid(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GridOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: GridWhereInput): GridOutput
  Hero(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeroOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: HeroWhereInput): HeroOutput
  Iframe(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: IframeOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: IframeWhereInput): IframeOutput
  Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ImageWhereInput): ImageOutput
  ImageMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ImageMediaWhereInput): ImageMediaOutput
  LandingPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LandingPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: LandingPageWhereInput): LandingPageOutput
  Marvin5Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: Marvin5ExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: Marvin5ExperienceWhereInput): Marvin5ExperienceOutput
  MarvinExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MarvinExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MarvinExperienceWhereInput): MarvinExperienceOutput
  MenuItem(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MenuItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MenuItemWhereInput): MenuItemOutput
  MockupPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MockupPageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: MockupPageWhereInput): MockupPageOutput
  OdpForm(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OdpFormOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OdpFormWhereInput): OdpFormOutput
  OptiFormsChoiceElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsChoiceElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsChoiceElementWhereInput): OptiFormsChoiceElementOutput
  OptiFormsCondition(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsConditionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsConditionWhereInput): OptiFormsConditionOutput
  OptiFormsContainerData(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsContainerDataOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsContainerDataWhereInput): OptiFormsContainerDataOutput
  OptiFormsDependencyRule(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsDependencyRuleOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsDependencyRuleWhereInput): OptiFormsDependencyRuleOutput
  OptiFormsNumberElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsNumberElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsNumberElementWhereInput): OptiFormsNumberElementOutput
  OptiFormsRangeElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsRangeElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsRangeElementWhereInput): OptiFormsRangeElementOutput
  OptiFormsResetElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsResetElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsResetElementWhereInput): OptiFormsResetElementOutput
  OptiFormsSelectionElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsSelectionElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsSelectionElementWhereInput): OptiFormsSelectionElementOutput
  OptiFormsSubmitElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsSubmitElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsSubmitElementWhereInput): OptiFormsSubmitElementOutput
  OptiFormsTextareaElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsTextareaElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsTextareaElementWhereInput): OptiFormsTextareaElementOutput
  OptiFormsTextboxElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsTextboxElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsTextboxElementWhereInput): OptiFormsTextboxElementOutput
  OptiFormsUrlElement(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: OptiFormsUrlElementOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: OptiFormsUrlElementWhereInput): OptiFormsUrlElementOutput
  PageAdminSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageAdminSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PageAdminSettingsWhereInput): PageAdminSettingsOutput
  PageSeoSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageSeoSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PageSeoSettingsWhereInput): PageSeoSettingsOutput
  Paragraph(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ParagraphOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: ParagraphWhereInput): ParagraphOutput
  PlaceholderItem(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PlaceholderItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PlaceholderItemWhereInput): PlaceholderItemOutput
  PlaceholdersConfiguration(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PlaceholdersConfigurationOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PlaceholdersConfigurationWhereInput): PlaceholdersConfigurationOutput
  PressRelease(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PressReleaseOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: PressReleaseWhereInput): PressReleaseOutput
  SiteSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SiteSettingsOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SiteSettingsWhereInput): SiteSettingsOutput
  SiteStyles(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SiteStylesOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SiteStylesWhereInput): SiteStylesOutput
  SysContentFolder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SysContentFolderOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: SysContentFolderWhereInput): SysContentFolderOutput
  TestimonialCard(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TestimonialCardOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TestimonialCardWhereInput): TestimonialCardOutput
  TestimonialCardComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TestimonialCardComponentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TestimonialCardComponentWhereInput): TestimonialCardComponentOutput
  Text(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TextOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: TextWhereInput): TextOutput
  Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoWhereInput): VideoOutput
  VideoExternal(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoExternalOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoExternalWhereInput): VideoExternalOutput
  VideoMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoMediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: VideoMediaWhereInput): VideoMediaOutput
  _AssetItem(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _AssetItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _AssetItemWhereInput): _AssetItemOutput
  _Component(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ComponentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ComponentWhereInput): _ComponentOutput
  _Content(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ContentOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ContentWhereInput): _ContentOutput
  _Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ExperienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ExperienceWhereInput): _ExperienceOutput
  _Folder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _FolderOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _FolderWhereInput): _FolderOutput
  _Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ImageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ImageWhereInput): _ImageOutput
  _ImageItem(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _ImageItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ImageItemWhereInput): _ImageItemOutput
  _Item(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: _ItemOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _ItemWhereInput): _ItemOutput
  _Media(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _MediaOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _MediaWhereInput): _MediaOutput
  _Page(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _PageOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _PageWhereInput): _PageOutput
  _Section(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _SectionOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _SectionWhereInput): _SectionOutput
  _Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _VideoOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: _VideoWhereInput): _VideoOutput
  amazon_exchange_experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: amazon_exchange_experienceOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: amazon_exchange_experienceWhereInput): amazon_exchange_experienceOutput
  cmp_Asset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_AssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_AssetWhereInput): cmp_AssetOutput
  cmp_CheckboxField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_CheckboxFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_CheckboxFieldWhereInput): cmp_CheckboxFieldOutput
  cmp_CurrencyField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_CurrencyFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_CurrencyFieldWhereInput): cmp_CurrencyFieldOutput
  cmp_DateField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_DateFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_DateFieldWhereInput): cmp_DateFieldOutput
  cmp_DropdownField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_DropdownFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_DropdownFieldWhereInput): cmp_DropdownFieldOutput
  cmp_Field(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_FieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_FieldWhereInput): cmp_FieldOutput
  cmp_ImageField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_ImageFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_ImageFieldWhereInput): cmp_ImageFieldOutput
  cmp_LabelField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_LabelFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_LabelFieldWhereInput): cmp_LabelFieldOutput
  cmp_NumberField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_NumberFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_NumberFieldWhereInput): cmp_NumberFieldOutput
  cmp_PercentField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PercentFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PercentFieldWhereInput): cmp_PercentFieldOutput
  cmp_PublicImageAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicImageAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicImageAssetWhereInput): cmp_PublicImageAssetOutput
  cmp_PublicRawFileAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicRawFileAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicRawFileAssetWhereInput): cmp_PublicRawFileAssetOutput
  cmp_PublicVideoAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_PublicVideoAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_PublicVideoAssetWhereInput): cmp_PublicVideoAssetOutput
  cmp_RadioField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_RadioFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_RadioFieldWhereInput): cmp_RadioFieldOutput
  cmp_RichTextField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_RichTextFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_RichTextFieldWhereInput): cmp_RichTextFieldOutput
  cmp_StructuredContentAsset(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_StructuredContentAssetOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_StructuredContentAssetWhereInput): cmp_StructuredContentAssetOutput
  cmp_TextAreaField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_TextAreaFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_TextAreaFieldWhereInput): cmp_TextAreaFieldOutput
  cmp_TextField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_TextFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_TextFieldWhereInput): cmp_TextFieldOutput
  cmp_VideoField(cursor: String, ids: [String], limit: Int! = 20, locale: [cmp_Locales], orderBy: cmp_VideoFieldOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: cmp_VideoFieldWhereInput): cmp_VideoFieldOutput
  marvinBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: marvinBlockOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: marvinBlockWhereInput): marvinBlockOutput
  test(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: testOrderByInput, pinned: PinnedInput, skip: Int! = 0, track: String, variation: VariationInput, where: testWhereInput): testOutput
}

input RangeFacetsInput {
  from: Int
  to: Int
}

enum Ranking {
  BOOST_ONLY
  DOC
  RELEVANCE
  SEMANTIC
}

type RichText {
  html: String
  json: JSON
}

type RichTextAutocomplete {
  html(limit: Int! = 10, value: String!): [String]
}

type RichTextFacet {
  html(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input RichTextOrderByInput {
  html: OrderBy
}

input RichTextWhereInput {
  html: StringFilterInput
}

type SearchableRichText {
  html(highlight: HighlightOptions): String
  json: JSON
}

type SearchableRichTextFacet {
  html(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input SearchableRichTextOrderByInput {
  html: OrderBy
}

input SearchableRichTextWhereInput {
  html: SearchableStringFilterInput
}

input SearchableStringFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int
  """`contains` performs full-text search on a word or phrase."""
  contains: String
  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: String
  """`exist` matches results that have this field."""
  exist: Boolean
  """
  enables supporting fuzzy matching on the query terms (keywords), which returns items that contain terms in the content similar to the keywords, as measured by a _Levenshtein edit distance_. An edit distance is the number of one-character changes needed to turn one term into another. The edit distance is based on the length of the term. 
  """
  fuzzy: Boolean
  """
  `in` matches with 1 or more exact values in a list. Example: `in: ["word1", "word2", "this is a phrase"]`
  """
  in: [String]
  """
  `like` matches on substrings with wildcard support: `%` to match on 0 or more characters, `_` to match on any character. 
  """
  like: String
  """
  `match` performs full-text search on a word or phrase where less relevant items are also returned. The `match` operator is only supported for `searchable` fields. It will improve fulltext search by making it easier to match on words. More exact matches will be ranked higher, less exact matches will be ranked lower. The `match` operator is supported with synonyms and fuzzy search.
  """
  match: String
  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: String
  """
  `not_in` returns results that do not match with 1 or more exact values in a list. Example: `not_in: ["word1", "word2", "this is a phrase"]`
  """
  notIn: [String]
  """
  `starts_with` retrieves matches that start with a certain value (prefix).
  """
  startsWith: String
  """
  expands query value with synonyms. Example: if `H2O` is a synonym of `water`, then querying for `water` will also return results with `H2O`.
  """
  synonyms: [SynonymSlot]
}

type SiteSettings implements IData & _IComponent & _IContent & _IItem {
  FooterLinks: [_IContent]
  FooterText(highlight: HighlightOptions): String
  HeaderLinks: [_IContent]
  Logo: ContentReference
  LogoResolution: String
  OptiWebProjectId: String
  SiteDomain(highlight: HighlightOptions): String
  SocialFacebook(highlight: HighlightOptions): String
  SocialGitHub(highlight: HighlightOptions): String
  SocialInstagram(highlight: HighlightOptions): String
  SocialTikTok(highlight: HighlightOptions): String
  SocialTwitter(highlight: HighlightOptions): String
  TopNavStyle: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type SiteSettingsAutocomplete {
  FooterLinks: _IContentAutocomplete
  HeaderLinks: _IContentAutocomplete
  Logo: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type SiteSettingsFacet {
  FooterLinks: _IContentFacet
  FooterText(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  HeaderLinks: _IContentFacet
  Logo: ContentReferenceFacet
  SiteDomain(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SocialFacebook(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SocialGitHub(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SocialInstagram(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SocialTikTok(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  SocialTwitter(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input SiteSettingsOrderByInput {
  FooterLinks: _IContentOrderByInput
  FooterText: OrderBy
  HeaderLinks: _IContentOrderByInput
  Logo: ContentReferenceOrderByInput
  SiteDomain: OrderBy
  SocialFacebook: OrderBy
  SocialGitHub: OrderBy
  SocialInstagram: OrderBy
  SocialTikTok: OrderBy
  SocialTwitter: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type SiteSettingsOutput {
  autocomplete: SiteSettingsAutocomplete
  cursor: String
  facets: SiteSettingsFacet
  item: SiteSettings
  items: [SiteSettings]
  total(all: Boolean): Int
}

input SiteSettingsWhereInput {
  FooterLinks: _IContentWhereInput
  FooterText: SearchableStringFilterInput
  HeaderLinks: _IContentWhereInput
  Logo: ContentReferenceWhereInput
  SiteDomain: SearchableStringFilterInput
  SocialFacebook: SearchableStringFilterInput
  SocialGitHub: SearchableStringFilterInput
  SocialInstagram: SearchableStringFilterInput
  SocialTikTok: SearchableStringFilterInput
  SocialTwitter: SearchableStringFilterInput
  _and: [SiteSettingsWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [SiteSettingsWhereInput]
  _or: [SiteSettingsWhereInput]
}

type SiteStyles implements IData & _IComponent & _IContent & _IItem {
  SiteStylesDomain(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  accent: String
  accentContent: String
  base100: String
  base200: String
  base300: String
  baseContent: String
  borderWidth: Float
  cssFile: _IContent
  daisyuiTheme: String
  depth: Boolean
  error: String
  errorContent: String
  font: String
  freeFormStyles: String
  info: String
  infoContent: String
  neutral: String
  neutralContent: String
  noise: Boolean
  primary: String
  primaryContent: String
  radiusBox: String
  radiusField: String
  radiusSelector: String
  secondary: String
  secondaryContent: String
  sizeField: String
  sizeSelector: String
  success: String
  successContent: String
  text2xl: String
  text3xl: String
  text4xl: String
  text5xl: String
  text6xl: String
  text7xl: String
  text8xl: String
  text9xl: String
  textBase: String
  textLg: String
  textSm: String
  textXl: String
  textXs: String
  warning: String
  warningContent: String
}

type SiteStylesAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  cssFile: _IContentAutocomplete
}

type SiteStylesFacet {
  SiteStylesDomain(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  cssFile: _IContentFacet
}

input SiteStylesOrderByInput {
  SiteStylesDomain: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  cssFile: _IContentOrderByInput
}

type SiteStylesOutput {
  autocomplete: SiteStylesAutocomplete
  cursor: String
  facets: SiteStylesFacet
  item: SiteStyles
  items: [SiteStyles]
  total(all: Boolean): Int
}

input SiteStylesWhereInput {
  SiteStylesDomain: SearchableStringFilterInput
  _and: [SiteStylesWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [SiteStylesWhereInput]
  _or: [SiteStylesWhereInput]
  cssFile: _IContentWhereInput
}

type StringFacet {
  count: Int
  name: String
}

input StringFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int
  """`ends_with` retrieves matches that end with a certain value (suffix)."""
  endsWith: String
  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: String
  """`exist` matches results that have this field."""
  exist: Boolean
  """
  enables supporting fuzzy matching on the query terms (keywords), which returns items that contain terms in the content similar to the keywords, as measured by a _Levenshtein edit distance_. An edit distance is the number of one-character changes needed to turn one term into another. The edit distance is based on the length of the term. 
  """
  fuzzy: Boolean
  """
  `in` matches with 1 or more exact values in a list. Example: `in: ["word1", "word2", "this is a phrase"]`
  """
  in: [String]
  """
  `like` matches on substrings with wildcard support: `%` to match on 0 or more characters, `_` to match on any character. 
  """
  like: String
  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: String
  """
  `not_in` returns results that do not match with 1 or more exact values in a list. Example: `not_in: ["word1", "word2", "this is a phrase"]`
  """
  notIn: [String]
  """
  `starts_with` retrieves matches that start with a certain value (prefix).
  """
  startsWith: String
  """
  expands query value with synonyms. Example: if `H2O` is a synonym of `water`, then querying for `water` will also return results with `H2O`.
  """
  synonyms: [SynonymSlot]
}

enum SynonymSlot {
  """synonym slot 1"""
  ONE
  """synonym slot 2"""
  TWO
}

type SysContentFolder implements IData & _IContent & _IFolder & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type SysContentFolderAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type SysContentFolderFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input SysContentFolderOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type SysContentFolderOutput {
  autocomplete: SysContentFolderAutocomplete
  cursor: String
  facets: SysContentFolderFacet
  item: SysContentFolder
  items: [SysContentFolder]
  total(all: Boolean): Int
}

input SysContentFolderWhereInput {
  _and: [SysContentFolderWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [SysContentFolderWhereInput]
  _or: [SysContentFolderWhereInput]
}

type TestimonialCard implements IData & _IComponent & _IContent & _IItem {
  AuthorAvatar: ContentReference
  AuthorName: String
  AuthorRole: String
  BackgroundColor: String
  BorderColor: String
  BorderWidth: Int
  QuoteText: RichText
  QuoteTextAlignment: String
  Rating: Int
  RatingColor: String
  ShowAvatar: Boolean
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type TestimonialCardAutocomplete {
  AuthorAvatar: ContentReferenceAutocomplete
  QuoteText: RichTextAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type TestimonialCardComponent implements IData & _IComponent & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  authorName: String
  authorRole: String
  backgroundColor: String
  borderThickness: Int
  quoteText: RichText
  rating: Int
  roundedCorners: String
  shadowStyle: String
  showAvatar: Boolean
}

type TestimonialCardComponentAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  quoteText: RichTextAutocomplete
}

type TestimonialCardComponentFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  quoteText: RichTextFacet
}

input TestimonialCardComponentOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  quoteText: RichTextOrderByInput
}

type TestimonialCardComponentOutput {
  autocomplete: TestimonialCardComponentAutocomplete
  cursor: String
  facets: TestimonialCardComponentFacet
  item: TestimonialCardComponent
  items: [TestimonialCardComponent]
  total(all: Boolean): Int
}

input TestimonialCardComponentWhereInput {
  _and: [TestimonialCardComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [TestimonialCardComponentWhereInput]
  _or: [TestimonialCardComponentWhereInput]
  quoteText: RichTextWhereInput
}

type TestimonialCardFacet {
  AuthorAvatar: ContentReferenceFacet
  QuoteText: RichTextFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input TestimonialCardOrderByInput {
  AuthorAvatar: ContentReferenceOrderByInput
  QuoteText: RichTextOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type TestimonialCardOutput {
  autocomplete: TestimonialCardAutocomplete
  cursor: String
  facets: TestimonialCardFacet
  item: TestimonialCard
  items: [TestimonialCard]
  total(all: Boolean): Int
}

input TestimonialCardWhereInput {
  AuthorAvatar: ContentReferenceWhereInput
  QuoteText: RichTextWhereInput
  _and: [TestimonialCardWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [TestimonialCardWhereInput]
  _or: [TestimonialCardWhereInput]
}

type Text implements IData & _IComponent & _IContent & _IItem {
  Content(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type TextAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type TextFacet {
  Content(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input TextOrderByInput {
  Content: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type TextOutput {
  autocomplete: TextAutocomplete
  cursor: String
  facets: TextFacet
  item: Text
  items: [Text]
  total(all: Boolean): Int
}

input TextWhereInput {
  Content: SearchableStringFilterInput
  _and: [TextWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [TextWhereInput]
  _or: [TextWhereInput]
}

enum VariationIncludeMode {
  ALL
  NONE
  SOME
}

input VariationInput {
  include: VariationIncludeMode
  includeOriginal: Boolean
  value: [String]
}

type Video implements IData & _IComponent & _IContent & _IItem {
  Video: ContentReference
  VideoPosterImage: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type VideoAutocomplete {
  Video: ContentReferenceAutocomplete
  VideoPosterImage: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type VideoExternal implements IData & _IComponent & _IContent & _IItem {
  DisplayWidth: String
  Params: String
  PlayLabel(highlight: HighlightOptions): String
  Poster: ContentReference
  Provider: String
  Video(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type VideoExternalAutocomplete {
  Poster: ContentReferenceAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type VideoExternalFacet {
  PlayLabel(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Poster: ContentReferenceFacet
  Video(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input VideoExternalOrderByInput {
  PlayLabel: OrderBy
  Poster: ContentReferenceOrderByInput
  Video: OrderBy
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type VideoExternalOutput {
  autocomplete: VideoExternalAutocomplete
  cursor: String
  facets: VideoExternalFacet
  item: VideoExternal
  items: [VideoExternal]
  total(all: Boolean): Int
}

input VideoExternalWhereInput {
  PlayLabel: SearchableStringFilterInput
  Poster: ContentReferenceWhereInput
  Video: SearchableStringFilterInput
  _and: [VideoExternalWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoExternalWhereInput]
  _or: [VideoExternalWhereInput]
}

type VideoFacet {
  Video: ContentReferenceFacet
  VideoPosterImage: ContentReferenceFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

type VideoMedia implements IData & _IAssetItem & _IContent & _IItem & _IMedia & _IVideo {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type VideoMediaAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type VideoMediaFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input VideoMediaOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type VideoMediaOutput {
  autocomplete: VideoMediaAutocomplete
  cursor: String
  facets: VideoMediaFacet
  item: VideoMedia
  items: [VideoMedia]
  total(all: Boolean): Int
}

input VideoMediaWhereInput {
  _and: [VideoMediaWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoMediaWhereInput]
  _or: [VideoMediaWhereInput]
}

input VideoOrderByInput {
  Video: ContentReferenceOrderByInput
  VideoPosterImage: ContentReferenceOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type VideoOutput {
  autocomplete: VideoAutocomplete
  cursor: String
  facets: VideoFacet
  item: Video
  items: [Video]
  total(all: Boolean): Int
}

input VideoWhereInput {
  Video: ContentReferenceWhereInput
  VideoPosterImage: ContentReferenceWhereInput
  _and: [VideoWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoWhereInput]
  _or: [VideoWhereInput]
}

type _AssetItem implements IData & _IAssetItem & _IItem {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type _AssetItemAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
}

type _AssetItemFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
}

input _AssetItemOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _AssetItemOutput {
  autocomplete: _AssetItemAutocomplete
  cursor: String
  facets: _AssetItemFacet
  item: _IAssetItem
  items: [_IAssetItem]
  total(all: Boolean): Int
}

input _AssetItemWhereInput {
  _and: [_AssetItemWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _modified: DateFilterInput
  _not: [_AssetItemWhereInput]
  _or: [_AssetItemWhereInput]
}

type _AssetMetadata {
  fileSize: Int
  mimeType: String
  url: String
}

type _AssetMetadataAutocomplete {
  mimeType(limit: Int! = 10, value: String!): [String]
  url(limit: Int! = 10, value: String!): [String]
}

type _AssetMetadataFacet {
  fileSize(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  mimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input _AssetMetadataOrderByInput {
  fileSize: OrderBy
  mimeType: OrderBy
  url: OrderBy
}

input _AssetMetadataWhereInput {
  fileSize: IntFilterInput
  mimeType: StringFilterInput
  url: StringFilterInput
}

type _Component implements IData & _IComponent & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _ComponentAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _ComponentFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _ComponentOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ComponentOutput {
  autocomplete: _ComponentAutocomplete
  cursor: String
  facets: _ComponentFacet
  item: _IComponent
  items: [_IComponent]
  total(all: Boolean): Int
}

input _ComponentWhereInput {
  _and: [_ComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ComponentWhereInput]
  _or: [_ComponentWhereInput]
}

type _Content implements IData & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _ContentAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _ContentFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _ContentOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ContentOutput {
  autocomplete: _ContentAutocomplete
  cursor: String
  facets: _ContentFacet
  item: _IContent
  items: [_IContent]
  total(all: Boolean): Int
}

input _ContentWhereInput {
  _and: [_ContentWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ContentWhereInput]
  _or: [_ContentWhereInput]
}

type _Experience implements IData & _IContent & _IExperience & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type _ExperienceAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type _ExperienceFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input _ExperienceOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type _ExperienceOutput {
  autocomplete: _ExperienceAutocomplete
  cursor: String
  facets: _ExperienceFacet
  item: _IExperience
  items: [_IExperience]
  total(all: Boolean): Int
}

input _ExperienceWhereInput {
  _and: [_ExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ExperienceWhereInput]
  _or: [_ExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type _Folder implements IData & _IContent & _IFolder & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _FolderAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _FolderFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _FolderOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _FolderOutput {
  autocomplete: _FolderAutocomplete
  cursor: String
  facets: _FolderFacet
  item: _IFolder
  items: [_IFolder]
  total(all: Boolean): Int
}

input _FolderWhereInput {
  _and: [_FolderWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_FolderWhereInput]
  _or: [_FolderWhereInput]
}

interface _IAssetItem implements IData & _IItem {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

interface _IComponent implements IData & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _IComponentFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _IComponentOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

input _IComponentWhereInput {
  _and: [_IComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_IComponentWhereInput]
  _or: [_IComponentWhereInput]
}

interface _IContent implements IData & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _IContentAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _IContentFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _IContentOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

input _IContentWhereInput {
  _and: [_IContentWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_IContentWhereInput]
  _or: [_IContentWhereInput]
}

interface _IExperience implements IData & _IContent & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

interface _IFolder implements IData & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

interface _IImage implements IData & _IAssetItem & _IContent & _IImageItem & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _imageMetadata: _ImageMetadata
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

interface _IImageItem implements IData & _IAssetItem & _IItem {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _imageMetadata: _ImageMetadata
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

interface _IItem implements IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

interface _IMedia implements IData & _IAssetItem & _IContent & _IItem {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

interface _IPage implements IData & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

interface _ISection implements IData & _IComponent & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

interface _IVideo implements IData & _IAssetItem & _IContent & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _Image implements IData & _IAssetItem & _IContent & _IImage & _IImageItem & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _imageMetadata: _ImageMetadata
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _ImageAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _ImageFacet {
  _assetMetadata: _AssetMetadataFacet
  _imageMetadata: _ImageMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

type _ImageItem implements IData & _IAssetItem & _IImageItem & _IItem {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _imageMetadata: _ImageMetadata
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type _ImageItemAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
}

type _ImageItemFacet {
  _assetMetadata: _AssetMetadataFacet
  _imageMetadata: _ImageMetadataFacet
  _itemMetadata: _MetadataFacet
}

input _ImageItemOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _imageMetadata: _ImageMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ImageItemOutput {
  autocomplete: _ImageItemAutocomplete
  cursor: String
  facets: _ImageItemFacet
  item: _IImageItem
  items: [_IImageItem]
  total(all: Boolean): Int
}

input _ImageItemWhereInput {
  _and: [_ImageItemWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _imageMetadata: _ImageMetadataWhereInput
  _itemMetadata: _MetadataWhereInput
  _modified: DateFilterInput
  _not: [_ImageItemWhereInput]
  _or: [_ImageItemWhereInput]
}

type _ImageMetadata {
  height: Int
  width: Int
}

type _ImageMetadataFacet {
  height(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  width(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
}

input _ImageMetadataOrderByInput {
  height: OrderBy
  width: OrderBy
}

input _ImageMetadataWhereInput {
  height: IntFilterInput
  width: IntFilterInput
}

input _ImageOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _imageMetadata: _ImageMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ImageOutput {
  autocomplete: _ImageAutocomplete
  cursor: String
  facets: _ImageFacet
  item: _IImage
  items: [_IImage]
  total(all: Boolean): Int
}

input _ImageWhereInput {
  _and: [_ImageWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _imageMetadata: _ImageMetadataWhereInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ImageWhereInput]
  _or: [_ImageWhereInput]
}

type _Item implements IData & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type _ItemAutocomplete {
  _itemMetadata: _MetadataAutocomplete
}

type _ItemFacet {
  _itemMetadata: _MetadataFacet
}

input _ItemOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ItemOutput {
  autocomplete: _ItemAutocomplete
  cursor: String
  facets: _ItemFacet
  item: _IItem
  items: [_IItem]
  total(all: Boolean): Int
}

input _ItemWhereInput {
  _and: [_ItemWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _modified: DateFilterInput
  _not: [_ItemWhereInput]
  _or: [_ItemWhereInput]
}

type _Media implements IData & _IAssetItem & _IContent & _IItem & _IMedia {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _MediaAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _MediaFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _MediaOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _MediaOutput {
  autocomplete: _MediaAutocomplete
  cursor: String
  facets: _MediaFacet
  item: _IMedia
  items: [_IMedia]
  total(all: Boolean): Int
}

input _MediaWhereInput {
  _and: [_MediaWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_MediaWhereInput]
  _or: [_MediaWhereInput]
}

type _Metadata {
  displayName(highlight: HighlightOptions): String
  key: String
  lastModified: Date
  type: String
}

type _MetadataAutocomplete {
  key(limit: Int! = 10, value: String!): [String]
  type(limit: Int! = 10, value: String!): [String]
}

type _MetadataFacet {
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  lastModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input _MetadataOrderByInput {
  displayName: OrderBy
  key: OrderBy
  lastModified: OrderBy
  type: OrderBy
}

input _MetadataWhereInput {
  displayName: SearchableStringFilterInput
  key: StringFilterInput
  lastModified: DateFilterInput
  type: StringFilterInput
}

type _Page implements IData & _IContent & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _PageAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _PageFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _PageOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _PageOutput {
  autocomplete: _PageAutocomplete
  cursor: String
  facets: _PageFacet
  item: _IPage
  items: [_IPage]
  total(all: Boolean): Int
}

input _PageWhereInput {
  _and: [_PageWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_PageWhereInput]
  _or: [_PageWhereInput]
}

type _Section implements IData & _IComponent & _IContent & _IItem & _ISection {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type _SectionAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type _SectionFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input _SectionOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type _SectionOutput {
  autocomplete: _SectionAutocomplete
  cursor: String
  facets: _SectionFacet
  item: _ISection
  items: [_ISection]
  total(all: Boolean): Int
}

input _SectionWhereInput {
  _and: [_SectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_SectionWhereInput]
  _or: [_SectionWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type _Video implements IData & _IAssetItem & _IContent & _IItem & _IMedia & _IVideo {
  _assetMetadata: _AssetMetadata
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type _VideoAutocomplete {
  _assetMetadata: _AssetMetadataAutocomplete
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type _VideoFacet {
  _assetMetadata: _AssetMetadataFacet
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input _VideoOrderByInput {
  _assetMetadata: _AssetMetadataOrderByInput
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _VideoOutput {
  autocomplete: _VideoAutocomplete
  cursor: String
  facets: _VideoFacet
  item: _IVideo
  items: [_IVideo]
  total(all: Boolean): Int
}

input _VideoWhereInput {
  _and: [_VideoWhereInput]
  _assetMetadata: _AssetMetadataWhereInput
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_VideoWhereInput]
  _or: [_VideoWhereInput]
}

type amazon_exchange_experience implements IData & _IContent & _IExperience & _IItem & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
  composition: CompositionStructureNode
}

type amazon_exchange_experienceAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type amazon_exchange_experienceFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input amazon_exchange_experienceOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type amazon_exchange_experienceOutput {
  autocomplete: amazon_exchange_experienceAutocomplete
  cursor: String
  facets: amazon_exchange_experienceFacet
  item: amazon_exchange_experience
  items: [amazon_exchange_experience]
  total(all: Boolean): Int
}

input amazon_exchange_experienceWhereInput {
  _and: [amazon_exchange_experienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [amazon_exchange_experienceWhereInput]
  _or: [amazon_exchange_experienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type cmp_Asset implements IData & Icmp_Asset {
  DateCreated: Date
  DateModified: Date
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FolderGuids: [String]
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_AssetAutocomplete {
  Fields: Icmp_FieldAutocomplete
  FolderGuids(limit: Int! = 10, value: String!): [String]
  Labels: cmp_AssetLabelAutocomplete
  LibraryPath(limit: Int! = 10, value: String!): [String]
  MimeType(limit: Int! = 10, value: String!): [String]
  ParentFolderGuid(limit: Int! = 10, value: String!): [String]
  Tags: cmp_TagAutocomplete
}

type cmp_AssetFacet {
  DateCreated(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  DateModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  ExpiryDate(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Fields: Icmp_FieldFacet
  FolderGuids(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Labels: cmp_AssetLabelFacet
  LibraryPath(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ParentFolderGuid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Tags: cmp_TagFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

type cmp_AssetLabel {
  Group: cmp_AssetLabelGroup
  Values: [cmp_AssetLabelValue]
}

type cmp_AssetLabelAutocomplete {
  Group: cmp_AssetLabelGroupAutocomplete
}

type cmp_AssetLabelFacet {
  Group: cmp_AssetLabelGroupFacet
  Values: cmp_AssetLabelValueFacet
}

type cmp_AssetLabelGroup {
  Id: String
  Name: String
}

type cmp_AssetLabelGroupAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
}

type cmp_AssetLabelGroupFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_AssetLabelGroupOrderByInput {
  Id: OrderBy
  Name: OrderBy
}

input cmp_AssetLabelGroupWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
}

input cmp_AssetLabelOrderByInput {
  Group: cmp_AssetLabelGroupOrderByInput
  Values: cmp_AssetLabelValueOrderByInput
}

type cmp_AssetLabelValue {
  Id: String
  Name: String
}

type cmp_AssetLabelValueFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_AssetLabelValueOrderByInput {
  Id: OrderBy
  Name: OrderBy
}

input cmp_AssetLabelValueWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
}

input cmp_AssetLabelWhereInput {
  Group: cmp_AssetLabelGroupWhereInput
  Values: cmp_AssetLabelValueWhereInput
}

input cmp_AssetOrderByInput {
  DateCreated: OrderBy
  DateModified: OrderBy
  ExpiryDate: OrderBy
  Fields: Icmp_FieldOrderByInput
  FolderGuids: OrderBy
  Id: OrderBy
  Labels: cmp_AssetLabelOrderByInput
  LibraryPath: OrderBy
  MimeType: OrderBy
  ParentFolderGuid: OrderBy
  Tags: cmp_TagOrderByInput
  Title: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_AssetOutput {
  autocomplete: cmp_AssetAutocomplete
  cursor: String
  facets: cmp_AssetFacet
  item: Icmp_Asset
  items: [Icmp_Asset]
  total(all: Boolean): Int
}

input cmp_AssetWhereInput {
  DateCreated: DateFilterInput
  DateModified: DateFilterInput
  ExpiryDate: DateFilterInput
  Fields: Icmp_FieldWhereInput
  FolderGuids: StringFilterInput
  Id: SearchableStringFilterInput
  Labels: cmp_AssetLabelWhereInput
  LibraryPath: StringFilterInput
  MimeType: StringFilterInput
  ParentFolderGuid: StringFilterInput
  Tags: cmp_TagWhereInput
  Title: SearchableStringFilterInput
  _and: [cmp_AssetWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_AssetWhereInput]
  _or: [cmp_AssetWhereInput]
}

type cmp_CheckboxField implements IData & Icmp_Field {
  Choices: [cmp_FieldChoiceProperty]
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_CheckboxFieldAutocomplete {
  Choices: cmp_FieldChoicePropertyAutocomplete
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_CheckboxFieldFacet {
  Choices: cmp_FieldChoicePropertyFacet
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_CheckboxFieldOrderByInput {
  Choices: cmp_FieldChoicePropertyOrderByInput
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_CheckboxFieldOutput {
  autocomplete: cmp_CheckboxFieldAutocomplete
  cursor: String
  facets: cmp_CheckboxFieldFacet
  item: cmp_CheckboxField
  items: [cmp_CheckboxField]
  total(all: Boolean): Int
}

input cmp_CheckboxFieldWhereInput {
  Choices: cmp_FieldChoicePropertyWhereInput
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_CheckboxFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_CheckboxFieldWhereInput]
  _or: [cmp_CheckboxFieldWhereInput]
}

type cmp_CurrencyField implements IData & Icmp_Field {
  CurrencyCode: String
  DecimalPlaces: Int
  HasThousandSeparator: Boolean
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_CurrencyFieldAutocomplete {
  CurrencyCode(limit: Int! = 10, value: String!): [String]
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_CurrencyFieldFacet {
  CurrencyCode(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  DecimalPlaces(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  HasThousandSeparator(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_CurrencyFieldOrderByInput {
  CurrencyCode: OrderBy
  DecimalPlaces: OrderBy
  HasThousandSeparator: OrderBy
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_CurrencyFieldOutput {
  autocomplete: cmp_CurrencyFieldAutocomplete
  cursor: String
  facets: cmp_CurrencyFieldFacet
  item: cmp_CurrencyField
  items: [cmp_CurrencyField]
  total(all: Boolean): Int
}

input cmp_CurrencyFieldWhereInput {
  CurrencyCode: StringFilterInput
  DecimalPlaces: IntFilterInput
  HasThousandSeparator: BoolFilterInput
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_CurrencyFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_CurrencyFieldWhereInput]
  _or: [cmp_CurrencyFieldWhereInput]
}

type cmp_DateField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_DateFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_DateFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_DateFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_DateFieldOutput {
  autocomplete: cmp_DateFieldAutocomplete
  cursor: String
  facets: cmp_DateFieldFacet
  item: cmp_DateField
  items: [cmp_DateField]
  total(all: Boolean): Int
}

input cmp_DateFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_DateFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_DateFieldWhereInput]
  _or: [cmp_DateFieldWhereInput]
  name: SearchableStringFilterInput
}

type cmp_DropdownField implements IData & Icmp_Field {
  Choices: [cmp_FieldChoiceProperty]
  Id: String
  IsMultiSelect: Boolean
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_DropdownFieldAutocomplete {
  Choices: cmp_FieldChoicePropertyAutocomplete
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_DropdownFieldFacet {
  Choices: cmp_FieldChoicePropertyFacet
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  IsMultiSelect(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_DropdownFieldOrderByInput {
  Choices: cmp_FieldChoicePropertyOrderByInput
  Id: OrderBy
  IsMultiSelect: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_DropdownFieldOutput {
  autocomplete: cmp_DropdownFieldAutocomplete
  cursor: String
  facets: cmp_DropdownFieldFacet
  item: cmp_DropdownField
  items: [cmp_DropdownField]
  total(all: Boolean): Int
}

input cmp_DropdownFieldWhereInput {
  Choices: cmp_FieldChoicePropertyWhereInput
  Id: StringFilterInput
  IsMultiSelect: BoolFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_DropdownFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_DropdownFieldWhereInput]
  _or: [cmp_DropdownFieldWhereInput]
}

type cmp_Field implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_FieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_FieldChoiceProperty {
  Id: String
  Name: String
}

type cmp_FieldChoicePropertyAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
}

type cmp_FieldChoicePropertyFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_FieldChoicePropertyOrderByInput {
  Id: OrderBy
  Name: OrderBy
}

input cmp_FieldChoicePropertyWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
}

type cmp_FieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_FieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_FieldOutput {
  autocomplete: cmp_FieldAutocomplete
  cursor: String
  facets: cmp_FieldFacet
  item: Icmp_Field
  items: [Icmp_Field]
  total(all: Boolean): Int
}

input cmp_FieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_FieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_FieldWhereInput]
  _or: [cmp_FieldWhereInput]
}

type cmp_FocalPoint {
  X: Int
  Y: Int
}

type cmp_FocalPointFacet {
  X(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  Y(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
}

input cmp_FocalPointOrderByInput {
  X: OrderBy
  Y: OrderBy
}

input cmp_FocalPointWhereInput {
  X: IntFilterInput
  Y: IntFilterInput
}

type cmp_ImageField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_ImageFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_ImageFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_ImageFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_ImageFieldOutput {
  autocomplete: cmp_ImageFieldAutocomplete
  cursor: String
  facets: cmp_ImageFieldFacet
  item: cmp_ImageField
  items: [cmp_ImageField]
  total(all: Boolean): Int
}

input cmp_ImageFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_ImageFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_ImageFieldWhereInput]
  _or: [cmp_ImageFieldWhereInput]
  name: SearchableStringFilterInput
}

type cmp_LabelField implements IData & Icmp_Field {
  Choices: [cmp_FieldChoiceProperty]
  Id: String
  IsMultiSelect: Boolean
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_LabelFieldAutocomplete {
  Choices: cmp_FieldChoicePropertyAutocomplete
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_LabelFieldFacet {
  Choices: cmp_FieldChoicePropertyFacet
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  IsMultiSelect(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_LabelFieldOrderByInput {
  Choices: cmp_FieldChoicePropertyOrderByInput
  Id: OrderBy
  IsMultiSelect: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_LabelFieldOutput {
  autocomplete: cmp_LabelFieldAutocomplete
  cursor: String
  facets: cmp_LabelFieldFacet
  item: cmp_LabelField
  items: [cmp_LabelField]
  total(all: Boolean): Int
}

input cmp_LabelFieldWhereInput {
  Choices: cmp_FieldChoicePropertyWhereInput
  Id: StringFilterInput
  IsMultiSelect: BoolFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_LabelFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_LabelFieldWhereInput]
  _or: [cmp_LabelFieldWhereInput]
}

enum cmp_Locales {
  ALL
  NEUTRAL
  en
}

type cmp_NumberField implements IData & Icmp_Field {
  DecimalPlaces: Int
  HasThousandSeparator: Boolean
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_NumberFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_NumberFieldFacet {
  DecimalPlaces(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  HasThousandSeparator(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_NumberFieldOrderByInput {
  DecimalPlaces: OrderBy
  HasThousandSeparator: OrderBy
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_NumberFieldOutput {
  autocomplete: cmp_NumberFieldAutocomplete
  cursor: String
  facets: cmp_NumberFieldFacet
  item: cmp_NumberField
  items: [cmp_NumberField]
  total(all: Boolean): Int
}

input cmp_NumberFieldWhereInput {
  DecimalPlaces: IntFilterInput
  HasThousandSeparator: BoolFilterInput
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_NumberFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_NumberFieldWhereInput]
  _or: [cmp_NumberFieldWhereInput]
}

type cmp_PercentField implements IData & Icmp_Field {
  DecimalPlaces: Int
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_PercentFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_PercentFieldFacet {
  DecimalPlaces(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_PercentFieldOrderByInput {
  DecimalPlaces: OrderBy
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_PercentFieldOutput {
  autocomplete: cmp_PercentFieldAutocomplete
  cursor: String
  facets: cmp_PercentFieldFacet
  item: cmp_PercentField
  items: [cmp_PercentField]
  total(all: Boolean): Int
}

input cmp_PercentFieldWhereInput {
  DecimalPlaces: IntFilterInput
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_PercentFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_PercentFieldWhereInput]
  _or: [cmp_PercentFieldWhereInput]
}

type cmp_PublicImageAsset implements IData & Icmp_Asset {
  AltText: String
  DateCreated: Date
  DateModified: Date
  Description(highlight: HighlightOptions): String
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FocalPoint: cmp_FocalPoint
  FolderGuids: [String]
  Height: Int
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Renditions: [cmp_RenditionProperty]
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  Url: String
  Width: Int
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_PublicImageAssetAutocomplete {
  AltText(limit: Int! = 10, value: String!): [String]
  Fields: Icmp_FieldAutocomplete
  FolderGuids(limit: Int! = 10, value: String!): [String]
  Labels: cmp_AssetLabelAutocomplete
  LibraryPath(limit: Int! = 10, value: String!): [String]
  MimeType(limit: Int! = 10, value: String!): [String]
  ParentFolderGuid(limit: Int! = 10, value: String!): [String]
  Renditions: cmp_RenditionPropertyAutocomplete
  Tags: cmp_TagAutocomplete
  Url(limit: Int! = 10, value: String!): [String]
}

type cmp_PublicImageAssetFacet {
  AltText(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  DateCreated(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  DateModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Description(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ExpiryDate(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Fields: Icmp_FieldFacet
  FocalPoint: cmp_FocalPointFacet
  FolderGuids(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Height(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Labels: cmp_AssetLabelFacet
  LibraryPath(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ParentFolderGuid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Renditions: cmp_RenditionPropertyFacet
  Tags: cmp_TagFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Url(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Width(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
}

input cmp_PublicImageAssetOrderByInput {
  AltText: OrderBy
  DateCreated: OrderBy
  DateModified: OrderBy
  Description: OrderBy
  ExpiryDate: OrderBy
  Fields: Icmp_FieldOrderByInput
  FocalPoint: cmp_FocalPointOrderByInput
  FolderGuids: OrderBy
  Height: OrderBy
  Id: OrderBy
  Labels: cmp_AssetLabelOrderByInput
  LibraryPath: OrderBy
  MimeType: OrderBy
  ParentFolderGuid: OrderBy
  Renditions: cmp_RenditionPropertyOrderByInput
  Tags: cmp_TagOrderByInput
  Title: OrderBy
  Url: OrderBy
  Width: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_PublicImageAssetOutput {
  autocomplete: cmp_PublicImageAssetAutocomplete
  cursor: String
  facets: cmp_PublicImageAssetFacet
  item: cmp_PublicImageAsset
  items: [cmp_PublicImageAsset]
  total(all: Boolean): Int
}

input cmp_PublicImageAssetWhereInput {
  AltText: StringFilterInput
  DateCreated: DateFilterInput
  DateModified: DateFilterInput
  Description: SearchableStringFilterInput
  ExpiryDate: DateFilterInput
  Fields: Icmp_FieldWhereInput
  FocalPoint: cmp_FocalPointWhereInput
  FolderGuids: StringFilterInput
  Height: IntFilterInput
  Id: SearchableStringFilterInput
  Labels: cmp_AssetLabelWhereInput
  LibraryPath: StringFilterInput
  MimeType: StringFilterInput
  ParentFolderGuid: StringFilterInput
  Renditions: cmp_RenditionPropertyWhereInput
  Tags: cmp_TagWhereInput
  Title: SearchableStringFilterInput
  Url: StringFilterInput
  Width: IntFilterInput
  _and: [cmp_PublicImageAssetWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_PublicImageAssetWhereInput]
  _or: [cmp_PublicImageAssetWhereInput]
}

type cmp_PublicRawFileAsset implements IData & Icmp_Asset {
  DateCreated: Date
  DateModified: Date
  Description(highlight: HighlightOptions): String
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FolderGuids: [String]
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  Url: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_PublicRawFileAssetAutocomplete {
  Fields: Icmp_FieldAutocomplete
  FolderGuids(limit: Int! = 10, value: String!): [String]
  Labels: cmp_AssetLabelAutocomplete
  LibraryPath(limit: Int! = 10, value: String!): [String]
  MimeType(limit: Int! = 10, value: String!): [String]
  ParentFolderGuid(limit: Int! = 10, value: String!): [String]
  Tags: cmp_TagAutocomplete
  Url(limit: Int! = 10, value: String!): [String]
}

type cmp_PublicRawFileAssetFacet {
  DateCreated(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  DateModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Description(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ExpiryDate(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Fields: Icmp_FieldFacet
  FolderGuids(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Labels: cmp_AssetLabelFacet
  LibraryPath(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ParentFolderGuid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Tags: cmp_TagFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Url(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_PublicRawFileAssetOrderByInput {
  DateCreated: OrderBy
  DateModified: OrderBy
  Description: OrderBy
  ExpiryDate: OrderBy
  Fields: Icmp_FieldOrderByInput
  FolderGuids: OrderBy
  Id: OrderBy
  Labels: cmp_AssetLabelOrderByInput
  LibraryPath: OrderBy
  MimeType: OrderBy
  ParentFolderGuid: OrderBy
  Tags: cmp_TagOrderByInput
  Title: OrderBy
  Url: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_PublicRawFileAssetOutput {
  autocomplete: cmp_PublicRawFileAssetAutocomplete
  cursor: String
  facets: cmp_PublicRawFileAssetFacet
  item: cmp_PublicRawFileAsset
  items: [cmp_PublicRawFileAsset]
  total(all: Boolean): Int
}

input cmp_PublicRawFileAssetWhereInput {
  DateCreated: DateFilterInput
  DateModified: DateFilterInput
  Description: SearchableStringFilterInput
  ExpiryDate: DateFilterInput
  Fields: Icmp_FieldWhereInput
  FolderGuids: StringFilterInput
  Id: SearchableStringFilterInput
  Labels: cmp_AssetLabelWhereInput
  LibraryPath: StringFilterInput
  MimeType: StringFilterInput
  ParentFolderGuid: StringFilterInput
  Tags: cmp_TagWhereInput
  Title: SearchableStringFilterInput
  Url: StringFilterInput
  _and: [cmp_PublicRawFileAssetWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_PublicRawFileAssetWhereInput]
  _or: [cmp_PublicRawFileAssetWhereInput]
}

type cmp_PublicVideoAsset implements IData & Icmp_Asset {
  AltText: String
  DateCreated: Date
  DateModified: Date
  Description(highlight: HighlightOptions): String
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FolderGuids: [String]
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Renditions: [cmp_RenditionProperty]
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  Url: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_PublicVideoAssetAutocomplete {
  AltText(limit: Int! = 10, value: String!): [String]
  Fields: Icmp_FieldAutocomplete
  FolderGuids(limit: Int! = 10, value: String!): [String]
  Labels: cmp_AssetLabelAutocomplete
  LibraryPath(limit: Int! = 10, value: String!): [String]
  MimeType(limit: Int! = 10, value: String!): [String]
  ParentFolderGuid(limit: Int! = 10, value: String!): [String]
  Renditions: cmp_RenditionPropertyAutocomplete
  Tags: cmp_TagAutocomplete
  Url(limit: Int! = 10, value: String!): [String]
}

type cmp_PublicVideoAssetFacet {
  AltText(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  DateCreated(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  DateModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Description(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ExpiryDate(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Fields: Icmp_FieldFacet
  FolderGuids(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Labels: cmp_AssetLabelFacet
  LibraryPath(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ParentFolderGuid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Renditions: cmp_RenditionPropertyFacet
  Tags: cmp_TagFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Url(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_PublicVideoAssetOrderByInput {
  AltText: OrderBy
  DateCreated: OrderBy
  DateModified: OrderBy
  Description: OrderBy
  ExpiryDate: OrderBy
  Fields: Icmp_FieldOrderByInput
  FolderGuids: OrderBy
  Id: OrderBy
  Labels: cmp_AssetLabelOrderByInput
  LibraryPath: OrderBy
  MimeType: OrderBy
  ParentFolderGuid: OrderBy
  Renditions: cmp_RenditionPropertyOrderByInput
  Tags: cmp_TagOrderByInput
  Title: OrderBy
  Url: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_PublicVideoAssetOutput {
  autocomplete: cmp_PublicVideoAssetAutocomplete
  cursor: String
  facets: cmp_PublicVideoAssetFacet
  item: cmp_PublicVideoAsset
  items: [cmp_PublicVideoAsset]
  total(all: Boolean): Int
}

input cmp_PublicVideoAssetWhereInput {
  AltText: StringFilterInput
  DateCreated: DateFilterInput
  DateModified: DateFilterInput
  Description: SearchableStringFilterInput
  ExpiryDate: DateFilterInput
  Fields: Icmp_FieldWhereInput
  FolderGuids: StringFilterInput
  Id: SearchableStringFilterInput
  Labels: cmp_AssetLabelWhereInput
  LibraryPath: StringFilterInput
  MimeType: StringFilterInput
  ParentFolderGuid: StringFilterInput
  Renditions: cmp_RenditionPropertyWhereInput
  Tags: cmp_TagWhereInput
  Title: SearchableStringFilterInput
  Url: StringFilterInput
  _and: [cmp_PublicVideoAssetWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_PublicVideoAssetWhereInput]
  _or: [cmp_PublicVideoAssetWhereInput]
}

type cmp_RadioField implements IData & Icmp_Field {
  Choices: [cmp_FieldChoiceProperty]
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
}

type cmp_RadioFieldAutocomplete {
  Choices: cmp_FieldChoicePropertyAutocomplete
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_RadioFieldFacet {
  Choices: cmp_FieldChoicePropertyFacet
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_RadioFieldOrderByInput {
  Choices: cmp_FieldChoicePropertyOrderByInput
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type cmp_RadioFieldOutput {
  autocomplete: cmp_RadioFieldAutocomplete
  cursor: String
  facets: cmp_RadioFieldFacet
  item: cmp_RadioField
  items: [cmp_RadioField]
  total(all: Boolean): Int
}

input cmp_RadioFieldWhereInput {
  Choices: cmp_FieldChoicePropertyWhereInput
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_RadioFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_RadioFieldWhereInput]
  _or: [cmp_RadioFieldWhereInput]
}

type cmp_RenditionProperty {
  Height: Int
  Id(highlight: HighlightOptions): String
  Name: String
  Url: String
  Width: Int
}

type cmp_RenditionPropertyAutocomplete {
  Name(limit: Int! = 10, value: String!): [String]
  Url(limit: Int! = 10, value: String!): [String]
}

type cmp_RenditionPropertyFacet {
  Height(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Url(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Width(filters: [String!], limit: Int, orderBy: OrderBy, orderType: OrderByFacetType, ranges: [RangeFacetsInput]): [NumberFacet]
}

input cmp_RenditionPropertyOrderByInput {
  Height: OrderBy
  Id: OrderBy
  Name: OrderBy
  Url: OrderBy
  Width: OrderBy
}

input cmp_RenditionPropertyWhereInput {
  Height: IntFilterInput
  Id: SearchableStringFilterInput
  Name: StringFilterInput
  Url: StringFilterInput
  Width: IntFilterInput
}

type cmp_RichTextField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_RichTextFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_RichTextFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_RichTextFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_RichTextFieldOutput {
  autocomplete: cmp_RichTextFieldAutocomplete
  cursor: String
  facets: cmp_RichTextFieldFacet
  item: cmp_RichTextField
  items: [cmp_RichTextField]
  total(all: Boolean): Int
}

input cmp_RichTextFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_RichTextFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_RichTextFieldWhereInput]
  _or: [cmp_RichTextFieldWhereInput]
  name: SearchableStringFilterInput
}

type cmp_StructuredContentAsset implements IData & Icmp_Asset {
  DateCreated: Date
  DateModified: Date
  ExpiryDate: Date
  Fields: [Icmp_Field]
  FolderGuids: [String]
  Id(highlight: HighlightOptions): String
  Labels: [cmp_AssetLabel]
  LibraryPath: String
  MimeType: String
  ParentFolderGuid: String
  Tags: [cmp_Tag]
  Title(highlight: HighlightOptions): String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_StructuredContentAssetAutocomplete {
  Fields: Icmp_FieldAutocomplete
  FolderGuids(limit: Int! = 10, value: String!): [String]
  Labels: cmp_AssetLabelAutocomplete
  LibraryPath(limit: Int! = 10, value: String!): [String]
  MimeType(limit: Int! = 10, value: String!): [String]
  ParentFolderGuid(limit: Int! = 10, value: String!): [String]
  Tags: cmp_TagAutocomplete
}

type cmp_StructuredContentAssetFacet {
  DateCreated(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  DateModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  ExpiryDate(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  Fields: Icmp_FieldFacet
  FolderGuids(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Labels: cmp_AssetLabelFacet
  LibraryPath(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  MimeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  ParentFolderGuid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Tags: cmp_TagFacet
  Title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_StructuredContentAssetOrderByInput {
  DateCreated: OrderBy
  DateModified: OrderBy
  ExpiryDate: OrderBy
  Fields: Icmp_FieldOrderByInput
  FolderGuids: OrderBy
  Id: OrderBy
  Labels: cmp_AssetLabelOrderByInput
  LibraryPath: OrderBy
  MimeType: OrderBy
  ParentFolderGuid: OrderBy
  Tags: cmp_TagOrderByInput
  Title: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_StructuredContentAssetOutput {
  autocomplete: cmp_StructuredContentAssetAutocomplete
  cursor: String
  facets: cmp_StructuredContentAssetFacet
  item: cmp_StructuredContentAsset
  items: [cmp_StructuredContentAsset]
  total(all: Boolean): Int
}

input cmp_StructuredContentAssetWhereInput {
  DateCreated: DateFilterInput
  DateModified: DateFilterInput
  ExpiryDate: DateFilterInput
  Fields: Icmp_FieldWhereInput
  FolderGuids: StringFilterInput
  Id: SearchableStringFilterInput
  Labels: cmp_AssetLabelWhereInput
  LibraryPath: StringFilterInput
  MimeType: StringFilterInput
  ParentFolderGuid: StringFilterInput
  Tags: cmp_TagWhereInput
  Title: SearchableStringFilterInput
  _and: [cmp_StructuredContentAssetWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_StructuredContentAssetWhereInput]
  _or: [cmp_StructuredContentAssetWhereInput]
  name: SearchableStringFilterInput
}

type cmp_Tag {
  Guid: String
  Name: String
}

type cmp_TagAutocomplete {
  Guid(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
}

type cmp_TagFacet {
  Guid(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_TagOrderByInput {
  Guid: OrderBy
  Name: OrderBy
}

input cmp_TagWhereInput {
  Guid: StringFilterInput
  Name: StringFilterInput
}

type cmp_TextAreaField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_TextAreaFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_TextAreaFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_TextAreaFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_TextAreaFieldOutput {
  autocomplete: cmp_TextAreaFieldAutocomplete
  cursor: String
  facets: cmp_TextAreaFieldFacet
  item: cmp_TextAreaField
  items: [cmp_TextAreaField]
  total(all: Boolean): Int
}

input cmp_TextAreaFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_TextAreaFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_TextAreaFieldWhereInput]
  _or: [cmp_TextAreaFieldWhereInput]
  name: SearchableStringFilterInput
}

type cmp_TextField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_TextFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_TextFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_TextFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_TextFieldOutput {
  autocomplete: cmp_TextFieldAutocomplete
  cursor: String
  facets: cmp_TextFieldFacet
  item: cmp_TextField
  items: [cmp_TextField]
  total(all: Boolean): Int
}

input cmp_TextFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_TextFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_TextFieldWhereInput]
  _or: [cmp_TextFieldWhereInput]
  name: SearchableStringFilterInput
}

type cmp_VideoField implements IData & Icmp_Field {
  Id: String
  Name: String
  Type: String
  Values: [String]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
  _track: String
  name(highlight: HighlightOptions): String
}

type cmp_VideoFieldAutocomplete {
  Id(limit: Int! = 10, value: String!): [String]
  Name(limit: Int! = 10, value: String!): [String]
  Type(limit: Int! = 10, value: String!): [String]
  Values(limit: Int! = 10, value: String!): [String]
}

type cmp_VideoFieldFacet {
  Id(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  Values(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  name(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input cmp_VideoFieldOrderByInput {
  Id: OrderBy
  Name: OrderBy
  Type: OrderBy
  Values: OrderBy
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  name: OrderBy
}

type cmp_VideoFieldOutput {
  autocomplete: cmp_VideoFieldAutocomplete
  cursor: String
  facets: cmp_VideoFieldFacet
  item: cmp_VideoField
  items: [cmp_VideoField]
  total(all: Boolean): Int
}

input cmp_VideoFieldWhereInput {
  Id: StringFilterInput
  Name: StringFilterInput
  Type: StringFilterInput
  Values: StringFilterInput
  _and: [cmp_VideoFieldWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [cmp_VideoFieldWhereInput]
  _or: [cmp_VideoFieldWhereInput]
  name: SearchableStringFilterInput
}

type marvinBlock implements IData & _IComponent & _IContent & _IItem {
  Text: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type marvinBlockAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type marvinBlockFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input marvinBlockOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type marvinBlockOutput {
  autocomplete: marvinBlockAutocomplete
  cursor: String
  facets: marvinBlockFacet
  item: marvinBlock
  items: [marvinBlock]
  total(all: Boolean): Int
}

input marvinBlockWhereInput {
  _and: [marvinBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [marvinBlockWhereInput]
  _or: [marvinBlockWhereInput]
}

enum system_Locales {
  ALL
  NEUTRAL
}

type test implements IData & _IComponent & _IContent & _IItem {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _itemMetadata: _Metadata
  _json: JSON
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  _track: String
}

type testAutocomplete {
  _itemMetadata: _MetadataAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type testFacet {
  _itemMetadata: _MetadataFacet
  _metadata: IContentMetadataFacet
}

input testOrderByInput {
  _itemMetadata: _MetadataOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking
  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type testOutput {
  autocomplete: testAutocomplete
  cursor: String
  facets: testFacet
  item: test
  items: [test]
  total(all: Boolean): Int
}

input testWhereInput {
  _and: [testWhereInput]
  _fulltext: SearchableStringFilterInput
  _itemMetadata: _MetadataWhereInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [testWhereInput]
  _or: [testWhereInput]
}

input usePinnedInput {
  collectionId: [String]
  phrase: String
}